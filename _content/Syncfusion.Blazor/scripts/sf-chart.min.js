(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-chart"],{

/***/ "./bundles/sf-chart.js":
/*!*****************************!*\
  !*** ./bundles/sf-chart.js ***!
  \*****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-chart.js */ "./modules/sf-chart.js");
/* harmony import */ var _modules_sf_chart_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_chart_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-chart.js":
/*!*****************************!*\
  !*** ./modules/sf-chart.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Chart = function () {
  'use strict';
  /* eslint-disable no-case-declarations */

  /* eslint-disable camelcase */

  /* eslint-disable @typescript-eslint/no-explicit-any */

  /**
   * Chart native blazor source file
   */

  var SfChart =
  /** @class */
  function () {
    function SfChart(id, element, dotnetRef, isZooming, isScrollbar, options, selectionHighlightOptions) {
      if (isZooming === void 0) {
        isZooming = false;
      }

      if (isScrollbar === void 0) {
        isScrollbar = false;
      }

      this.mouseY = 0;
      this.mouseX = 0;
      this.eventInterval = 80;
      this.mouseMoveRef = null;
      this.mouseMoveThreshold = null;
      this.chartOnMouseClickRef = null;
      this.chartRightClickRef = null;
      this.mouseLeaveRef = null;
      this.chartKeyDownRef = null;
      this.chartKeyUpRef = null;
      this.chartMouseWheelRef = null;
      this.chartOnMouseDownRef = null;
      this.mouseEndRef = null;
      this.chartMouseWheelThreshold = null;
      this.domMouseMoveRef = null;
      this.domMouseMoveThreshold = null;
      this.scrollbarMouseMoveThreshold = null;
      this.scrollbarMouseWheelThreshold = null;
      this.domMouseUpRef = null;
      this.longPressBound = null;
      this.touchObject = null; //values to be passed

      this.highlightMode = 'None';
      this.selectionMode = 'None';
      this.rectSeries = true;
      this.isSeriesMode = false;
      this.seriesTypes = [];
      this.selectedDataIndexes = [];
      this.highlightDataIndexes = [];
      this.previousSelectedEle = [];
      this.highlightColor = '';
      this.highlightPattern = 'None';
      this.selectionPattern = 'None';
      this.legendModule = [];
      this.allowMultiSelection = false;
      this.pinchStyle = 'opacity: 0; position: absolute; display: block; width: 100px; height: 100px; background: transparent; border: 2px solid blue;';
      this.pinchtarget = null;

      this.documentKeyHandler = function (e) {
        // 74 - J
        if (e.altKey && e.keyCode === 74 && !sf.base.isNullOrUndefined(this.element)) {
          this.element.focus();
        }
      };

      this.id = id;
      this.element = element;
      this.dotnetref = dotnetRef;
      this.isZooming = isZooming;
      this.isScrollbar = isScrollbar;
      this.element.blazor__instance = this;
      this.options = options;
      this.currentLegendIndex = 0;
      this.currentPointIndex = 0;
      this.currentSeriesIndex = 0;
      this.previousTargetId = "";
      this.isZoomed = false;
      this.selectionHighlightOptions(selectionHighlightOptions);
      this.selectedDataIndexes = selectionHighlightOptions.selectedDataIndexes || [];
      this.unSelected = id + "_ej2_deselected";
    }

    SfChart.prototype.render = function () {
      this.unWireEvents(this.id, this.dotnetref);
      this.wireEvents(this.id, this.dotnetref);
    };

    SfChart.prototype.destroy = function () {
      this.unWireEvents(this.id, this.dotnetref);
      this.dotnetref.invokeMethodAsync("DisposeDotNetReference");
    };

    SfChart.prototype.selectionHighlightOptions = function (options) {
      this.highlightMode = options.highlightMode;
      this.selectionMode = options.selectionMode;
      this.seriesTypes = options.seriesTypes;
      this.highlightColor = options.highlightColor;
      this.highlightPattern = options.highlightPattern;
      this.selectionPattern = options.selectionPattern;
      this.allowMultiSelection = options.allowMultiSelection;
      this.oldMode = this.currentMode;
    };

    SfChart.prototype.unWireEvents = function (id, dotnetref) {
      var element = document.getElementById(id);

      if (!element) {
        return;
      }

      this.dotnetref = dotnetref;
      Chart.dotnetrefCollection = Chart.dotnetrefCollection.filter(function (item) {
        return item.id !== id;
      });
      /*! Find the Events type */

      var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
      /*! Bind the Event handler */

      element.removeEventListener('mousemove', this.mouseMoveRef);
      element.removeEventListener('touchmove', this.mouseMoveRef);
      sf.base.EventHandler.remove(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
      sf.base.EventHandler.remove(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
      sf.base.EventHandler.remove(element, 'click', this.chartOnMouseClickRef);
      sf.base.EventHandler.remove(element, 'contextmenu', this.chartRightClickRef);
      sf.base.EventHandler.remove(element, cancelEvent, this.mouseLeaveRef);
      sf.base.EventHandler.remove(element, 'keydown', this.chartKeyDownRef);
      sf.base.EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
      sf.base.EventHandler.remove(element, 'keyup', this.chartKeyUpRef);

      if (this.isZooming) {
        var wheelEvent = sf.base.Browser.info.name === 'mozilla' ? sf.base.Browser.isPointer ? 'mousewheel' : 'DOMMouseScroll' : 'mousewheel';
        element.removeEventListener(wheelEvent, this.chartMouseWheelRef);
      }

      if (this.isScrollbar) {
        window.removeEventListener('mousemove', this.domMouseMoveRef);
        window.removeEventListener('mouseup', this.domMouseUpRef, false);
      }

      var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
      sf.base.EventHandler.remove(window, resize, Chart.resizeBound);

      if (this.touchObject) {
        this.touchObject.destroy();
        this.touchObject = null;
      }
      /*! Apply the style for chart */

    };

    SfChart.prototype.wireEvents = function (id, dotnetref) {
      var element = document.getElementById(id);

      if (!element) {
        return;
      }

      this.dotnetref = dotnetref;
      Chart.dotnetrefCollection.push({
        id: id,
        dotnetref: dotnetref
      });
      /*! Find the Events type */

      var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
      this.chartOnMouseDownRef = this.chartOnMouseDown.bind(this, dotnetref, id);
      this.mouseEndRef = this.mouseEnd.bind(this, dotnetref, id);
      this.mouseMoveRef = this.mouseMove.bind(this, dotnetref, id);
      this.chartOnMouseClickRef = this.chartOnMouseClick.bind(this, dotnetref, id);
      this.chartRightClickRef = this.chartRightClick.bind(this, dotnetref, id);
      this.chartKeyDownRef = this.chartOnKeyDown.bind(this, this.dotnetref, this.id);
      this.chartKeyUpRef = this.chartOnKeyUp.bind(this, this.dotnetref, this.id);
      this.mouseLeaveRef = this.mouseLeave.bind(this, dotnetref, id);
      /*! Bind the Event handler */

      element.addEventListener('mousemove', this.mouseMoveRef);
      element.addEventListener('touchmove', this.mouseMoveRef);
      sf.base.EventHandler.add(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
      sf.base.EventHandler.add(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
      sf.base.EventHandler.add(element, 'click', this.chartOnMouseClickRef);
      sf.base.EventHandler.add(element, 'contextmenu', this.chartRightClickRef);
      sf.base.EventHandler.add(element, cancelEvent, this.mouseLeaveRef);
      sf.base.EventHandler.add(element, "keydown", this.chartKeyDownRef);
      sf.base.EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
      sf.base.EventHandler.add(element, "keyup", this.chartKeyUpRef);

      if (this.isZooming) {
        this.chartMouseWheelRef = this.chartMouseWheel.bind(this, dotnetref, id);
        var wheelEvent = sf.base.Browser.info.name === 'mozilla' ? sf.base.Browser.isPointer ? 'mousewheel' : 'DOMMouseScroll' : 'mousewheel';
        element.addEventListener(wheelEvent, this.chartMouseWheelRef);
      }

      if (this.isScrollbar) {
        this.domMouseMoveRef = this.domMouseMove.bind(this, dotnetref, id);
        this.domMouseUpRef = this.domMouseUp.bind(this, dotnetref, id);
        window.addEventListener('mousemove', this.domMouseMoveRef);
        window.addEventListener('mouseup', this.domMouseUpRef, false);
      }

      Chart.resizeBound = Chart.chartResize.bind(this, Chart.dotnetrefCollection);
      var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
      sf.base.EventHandler.add(window, resize, Chart.resizeBound);
      this.longPressBound = this.longPress.bind(this, dotnetref, id);
      this.touchObject = new sf.base.Touch(element, {
        tapHold: this.longPressBound,
        tapHoldThreshold: 500
      });
      /*! Apply the style for chart */
    };

    SfChart.prototype.getEventArgs = function (e, id) {
      var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
      var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
      this.setMouseXY(clientX, clientY, id);
      var touches = e.touches;
      var touchList = [];

      if (e.type.indexOf('touch') > -1) {
        for (var i = 0, length_1 = touches.length; i < length_1; i++) {
          touchList.push({
            pageX: touches[i].clientX,
            pageY: touches[i].clientY,
            pointerId: e.pointerId || 0
          });
        }
      }

      return {
        type: e.type,
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        pointerType: e.pointerType,
        target: e.target.id,
        changedTouches: {
          clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
          clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
        },
        touches: touchList,
        pointerId: e.pointerId
      };
    };

    SfChart.prototype.getWheelArgs = function (e, id) {
      this.setMouseXY(e.clientX, e.clientY, id);
      return {
        detail: e.detail,
        wheelDelta: e['wheelDelta'],
        target: e.currentTarget ? e.currentTarget['id'] : e.srcElement ? e.srcElement['id'] : e.target ? e.target['id'] : '',
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        browserName: sf.base.Browser.info.name,
        isPointer: sf.base.Browser.isPointer
      };
    };

    SfChart.prototype.setMouseXY = function (pageX, pageY, id) {
      var svgRect = document.getElementById(id.replace('_stockChart_chart', '') + '_svg').getBoundingClientRect();
      var rect = document.getElementById(id).getBoundingClientRect();
      this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
      this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
    };

    SfChart.prototype.chartOnMouseDown = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;

      if (e.type.indexOf('touch') > -1) {
        var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        this.pinchtarget = document.getElementById('pinchtarget');
        this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: ' + (clientY - 50) + 'px; left: ' + (clientX - 50) + 'px;');
      }

      dotnetref.invokeMethodAsync('OnZoomingMouseDown', this.getEventArgs(e, id));
      return false;
    };

    SfChart.prototype.chartMouseWheel = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      dotnetref.invokeMethodAsync('OnChartMouseWheel', this.getWheelArgs(e, id));
      e.preventDefault();
      return false;
    };

    SfChart.prototype.mouseMove = function (dotnetref, id, e) {
      var target = e.target;

      if (this.highlightMode !== 'None') {
        if (!sf.base.isNullOrUndefined(target) || target.id.indexOf('Point') > -1 || target.id.indexOf('Symbol') > -1) {
          if (target.id.indexOf('text') > -1) {
            target = Chart.findDOMElement(target.id.replace('text', 'shape'));
          } else {
            target = Chart.findDOMElement(target.id);
          }

          if (target.hasAttribute('class') && (target.getAttribute('class').indexOf('highlight') > -1 || target.getAttribute('class').indexOf('selection') > -1)) {
            return;
          }
        }

        Chart.calculateSelectedElements(e, this.element);

        if (target.id.indexOf('legend') > 0) {
          this.legendVisible = true;
          Chart.legendSelection(e, this.element);
        }
      }

      if (this.mouseMoveThreshold == null || new Date().getTime() - this.mouseMoveThreshold > this.eventInterval) {
        this.mouseMoveThreshold = new Date().getTime();
        var pageX = void 0;
        var pageY = void 0;
        var touchArg = void 0;

        if (e.type === 'touchmove') {
          this.isTouch = true;
          touchArg = e;
          pageX = touchArg.changedTouches[0].clientX;
          pageY = touchArg.changedTouches[0].clientY;

          if (this.pinchtarget) {
            this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: ' + (pageY - 50) + 'px; left: ' + (pageX - 50) + 'px;');
            e.preventDefault();
          }

          e.preventDefault();
        } else {
          this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
          pageX = e.clientX;
          pageY = e.clientY;
        }

        this.dotnetref = dotnetref;

        if (document.getElementById(id.replace('_stockChart_chart', '') + '_svg')) {
          this.setMouseXY(pageX, pageY, id);
          dotnetref.invokeMethodAsync('OnZoomingMouseMove', this.getEventArgs(e, id));
        }
      }
    };

    SfChart.prototype.mouseEnd = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;

      if (this.pinchtarget) {
        this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: -100px; left: -100px;');
      }

      dotnetref.invokeMethodAsync('OnZoomingMouseEnd', this.getEventArgs(e, id));
      return false;
    };

    SfChart.prototype.chartOnMouseClick = function (dotnetref, id, e) {
      Chart.calculateSelectedElements(e, this.element);
      var target = e.target;

      if (target.id.indexOf('legend') > 0) {
        this.legendVisible = true;
        Chart.legendSelection(e, this.element);
      }
    };

    SfChart.prototype.chartRightClick = function (dotnetref, id, event) {
      this.dotnetref = dotnetref;
      event.preventDefault();
      event.stopPropagation();
      dotnetref.invokeMethodAsync('OnChartMouseRightClick', this.getEventArgs(event, id));
      return false;
    };

    SfChart.prototype.chartOnKeyDown = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var actionKey = "";

      if (this.isZoomed && e.code == "Tab" || e.code == "Space") {
        e.preventDefault();
      }

      if (this.options.showTooltip && (e.code == "Tab" && this.previousTargetId.indexOf("Series") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }

      if (e.ctrlKey && (e.key === '+' || e.code === 'Equal' || e.key === '-' || e.code === 'Minus')) {
        e.preventDefault();
        this.isZoomed = this.options.enableZoom;
        Chart.fadeOut(this.element);
        actionKey = this.isZoomed ? e.code : "";
      } else if (e["keyCode"] === 82 && this.isZoomed) {
        // KeyCode 82 (R) for reseting
        e.preventDefault();
        this.isZoomed = false;
        actionKey = "R";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        actionKey = this.isZoomed ? e.code : "";
      }

      if (e.ctrlKey && e.key === 'p') {
        e.preventDefault();
        actionKey = "CtrlP";
      }

      if (actionKey != "") dotnetref.invokeMethodAsync("OnChartKeyboardNavigations", actionKey, e.target['id']);
      return false;
    };

    SfChart.prototype.chartOnKeyUp = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var actionKey = "";
      var targetId = e.target['id'];
      var groupElement;
      var markerGroup;
      var targetElement = e.target;
      var titleElement = Chart.getElement(this.element.id + "_ChartTitle");
      var seriesElement = Chart.getElement(this.element.id + "SeriesCollection");
      var legendElement = Chart.getElement(this.element.id + "_chart_legend_translate_g");
      var pagingElement = Chart.getElement(this.element.id + "_chart_legend_pageup");

      if (!this.isZoomed && e.keyCode !== 82) {
        if (titleElement) {
          titleElement.setAttribute("class", "e-chart-focused");
        }

        if (seriesElement && seriesElement.firstElementChild) {
          var firstChild = seriesElement.firstElementChild.children[1];
          var className = firstChild.getAttribute("class");

          if (className && className.indexOf("e-chart-focused") === -1) {
            className = className + " e-chart-focused";
          } else if (!className) {
            className = "e-chart-focused";
          }

          firstChild.setAttribute("class", className + " e-chart-focused");
        }

        if (legendElement) {
          var firstChild = legendElement.firstElementChild;
          var className = firstChild.getAttribute("class");

          if (className && className.indexOf("e-chart-focused") === -1) {
            className = className + " e-chart-focused";
          } else if (!className) {
            className = "e-chart-focused";
          }

          firstChild.setAttribute("class", className);
        }

        if (pagingElement) {
          pagingElement.setAttribute("class", "e-chart-focused");
        }

        if (e.code == "Tab") {
          if (this.previousTargetId != "") {
            if (this.previousTargetId.indexOf("_Series_") > -1 && targetId.indexOf("_Series_") == -1) {
              groupElement = Chart.getElement(this.element.id + "SeriesCollection");
              var previousElement = this.previousTargetId.indexOf("_Symbol") > -1 ? Chart.getElement(this.element.id + "SymbolGroup" + this.currentSeriesIndex).children[this.currentPointIndex + 1] : this.previousTargetId.indexOf("_Point_") > -1 ? groupElement.children[this.currentSeriesIndex].children[this.currentPointIndex + 1] : groupElement.children[this.currentSeriesIndex];
              Chart.setTabIndex(previousElement, groupElement.firstElementChild);
              this.currentPointIndex = 0;
              this.currentSeriesIndex = 0;
            } else if (this.previousTargetId.indexOf("_chart_legend_page") > -1 && targetId.indexOf("_chart_legend_page") == -1 && targetId.indexOf("_chart_legend_g_") == -1) {
              Chart.setTabIndex(e.target, Chart.getElement(this.element.id + "_chart_legend_pageup"));
            } else if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("_chart_legend_g_") == -1) {
              groupElement = Chart.getElement(this.element.id + "_chart_legend_translate_g");
              Chart.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
            }
          }

          this.previousTargetId = targetId;

          if (targetId.indexOf("SeriesGroup") > -1) {
            this.currentSeriesIndex = +targetId.split("SeriesGroup")[1];
            targetElement.removeAttribute("tabindex");
            targetElement.blur();

            if (targetElement.children[1].id.indexOf("_Point_") == -1) {
              markerGroup = Chart.getElement(this.element.id + "SymbolGroup" + targetId.split("SeriesGroup")[1]);
            }

            targetId = Chart.focusChild(markerGroup != null ? markerGroup.children[1] : targetElement.children[1]);
          }

          actionKey = this.options.enableHighlight || this.options.showTooltip ? "Tab" : "";
        } else if (e.code.indexOf("Arrow") > -1) {
          e.preventDefault();
          this.previousTargetId = targetId;

          if (targetId.indexOf("_chart_legend_page") > -1) {
            if (e.code == "ArrowLeft") {
              Chart.getElement(this.element.id + "_chart_legend_pagedown").removeAttribute("tabindex");
              Chart.focusChild(Chart.getElement(this.element.id + "_chart_legend_pageup"));
            } else if (e.code == "ArrowRight") {
              Chart.getElement(this.element.id + "_chart_legend_pageup").removeAttribute("tabindex");
              Chart.focusChild(Chart.getElement(this.element.id + "_chart_legend_pagedown"));
            }
          } else if (targetId.indexOf("_chart_legend_") > -1) {
            var legendElement_1 = targetElement.parentElement.children;
            legendElement_1[this.currentLegendIndex].removeAttribute("tabindex");
            this.currentLegendIndex += e.code == "ArrowUp" || e.code == "ArrowRight" ? +1 : -1;
            this.currentLegendIndex = Chart.getActualIndex(this.currentLegendIndex, legendElement_1.length);
            var currentLegend = legendElement_1[this.currentLegendIndex];
            Chart.focusChild(currentLegend);
            targetId = currentLegend.children[1].id;
            actionKey = this.options.enableHighlight ? "ArrowMove" : "";
          } else if (targetId.indexOf("_Series_") > -1) {
            groupElement = targetElement.parentElement.parentElement;
            var currentPoint = e.target;
            targetElement.removeAttribute("tabindex");
            targetElement.blur();

            if (e.code == "ArrowRight" || e.code == "ArrowLeft") {
              var seriesIndexes = [];

              for (var i = 0; i < groupElement.children.length; i++) {
                if (groupElement.children[i].id.indexOf("SeriesGroup") > -1) {
                  seriesIndexes.push(+groupElement.children[i].id.split("SeriesGroup")[1]);
                }
              }

              this.currentSeriesIndex = seriesIndexes.indexOf(this.currentSeriesIndex) + (e.code == "ArrowRight" ? 1 : -1);
              this.currentPointIndex = 0;
              this.currentSeriesIndex = seriesIndexes[Chart.getActualIndex(this.currentSeriesIndex, seriesIndexes.length)];
              groupElement = Chart.getElement(this.element.id + "SeriesGroup" + this.currentSeriesIndex);
              markerGroup = Chart.getElement(this.element.id + "SymbolGroup" + this.currentSeriesIndex);
              currentPoint = groupElement.children[1].id.indexOf("_Point_") == -1 && markerGroup ? markerGroup.children[1] : groupElement.children[1];
            } else {
              this.currentPointIndex += e.code == "ArrowUp" ? 1 : -1;

              if (targetId.indexOf("_Symbol") > -1) {
                this.currentPointIndex = Chart.getActualIndex(this.currentPointIndex, Chart.getElement(this.element.id + "SymbolGroup" + this.currentSeriesIndex).childElementCount - 1);
                currentPoint = Chart.getElement(this.element.id + "_Series_" + this.currentSeriesIndex + "_Point_" + this.currentPointIndex + "_Symbol");
              } else if (targetId.indexOf("_Point_") > -1) {
                this.currentPointIndex = Chart.getActualIndex(this.currentPointIndex, Chart.getElement(this.element.id + "SeriesGroup" + this.currentSeriesIndex).childElementCount - 1);
                currentPoint = Chart.getElement(this.element.id + "_Series_" + this.currentSeriesIndex + "_Point_" + this.currentPointIndex);
              }
            }

            targetId = Chart.focusChild(currentPoint);
            actionKey = this.options.showTooltip ? "ArrowMove" : "";
          }
        } else if ((e.code == "Enter" || e.code == "Space") && (targetId.indexOf("_chart_legend_") > -1 || targetId.indexOf("_Point_") > -1)) {
          targetId = targetId.indexOf("_chart_legend_page") > -1 ? targetId : targetId.indexOf("_chart_legend_") > -1 ? targetElement.children[1].id : targetId;
          actionKey = "Enter";
        }
      }

      if (actionKey != "") dotnetref.invokeMethodAsync("OnChartKeyboardNavigations", actionKey, targetId);
      return false;
    };

    SfChart.prototype.mouseLeave = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      dotnetref.invokeMethodAsync('OnChartMouseLeave', this.getEventArgs(e, id));
      return false;
    };

    SfChart.prototype.longPress = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var clientX = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientX : 0;
      var clientY = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientY : 0;
      this.setMouseXY(clientX, clientY, id);
      var args = {
        type: 'TapHold',
        clientX: clientX,
        clientY: clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        pointerType: '',
        target: '',
        changedTouches: {
          clientX: clientX,
          clientY: clientY
        },
        touches: [],
        pointerId: 0
      };
      dotnetref.invokeMethodAsync('OnChartLongPress', args);
      return false;
    };

    SfChart.prototype.domMouseMove = function (dotnetref, id, event) {
      if (this.domMouseMoveThreshold == null || new Date().getTime() - this.domMouseMoveThreshold > this.eventInterval) {
        this.domMouseMoveThreshold = new Date().getTime();

        if (!sf.base.isNullOrUndefined(Chart.svgId) && Chart.svgId.indexOf(id) > -1) {
          var evtArgs = Chart.getScrollEventArgs(event, true);
          dotnetref.invokeMethodAsync('ScrollMouseMove', evtArgs);
        }
      }

      return false;
    };

    SfChart.prototype.domMouseUp = function (dotnetref, id, event) {
      if (!sf.base.isNullOrUndefined(Chart.svgId) && Chart.svgId.indexOf(id) > -1) {
        var evtArgs = Chart.getScrollEventArgs(event, true);
        dotnetref.invokeMethodAsync('ScrollMouseUp', evtArgs);
        Chart.svgId = null;
      }

      return false;
    };

    return SfChart;
  }();

  var Index =
  /** @class */
  function () {
    function Index(seriesIndex, pointIndex) {
      this.series = seriesIndex;
      this.point = pointIndex;
    }

    return Index;
  }();

  var Chart = {
    initialize: function initialize(element, dotnetRef, isZooming, isScrollbar, options, selectionHighlightOptions) {
      var instance = new SfChart(element.id, element, dotnetRef, isZooming, isScrollbar, options, selectionHighlightOptions);
      instance.render();
    },
    destroy: function destroy(element) {
      var currentInstance = element.blazor__instance;

      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.destroy();
      }
    },
    setHighlightSelectionOptions: function setHighlightSelectionOptions(element, selectionHighlightOptions) {
      var currentInstance = element.blazor__instance;

      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.selectionHighlightOptions(selectionHighlightOptions);
      }
    },
    invokeBlurEffect: function invokeBlurEffect(element) {
      if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
        this.blurEffect(element.id, element.blazor__instance);
      }
    },
    invokeRemoveSelectedElements: function invokeRemoveSelectedElements(element) {
      var chart = element.blazor__instance;

      if (!sf.base.isNullOrUndefined(chart)) {
        chart.selectedDataIndexes = [];
        this.removeSelectedElements(element.blazor__instance);
      }
    },
    redrawSelection: function redrawSelection(element) {
      var chart = element.blazor__instance;
      chart.isSeriesMode = chart.oldMode == "Series";
      var chartSelectedDatas = chart.selectedDataIndexes;
      var charthighlightedDatas = chart.highlightDataIndexes;

      if (chart.styleId.indexOf("highlight") > -1 && chart.highlightDataIndexes.length > 0) {
        chart.highlightDataIndexes = [];
        this.removeSelectedElements(chart);
        chartSelectedDatas = charthighlightedDatas;
      } else {
        chart.selectedDataIndexes = [];
        this.removeSelectedElements(chart);
      }

      this.blurEffect(element.id, chart);
      this.selectDataIndex(element, chartSelectedDatas);
    },
    removeSelectedElements: function removeSelectedElements(chart) {
      for (var i = 0; i < chart.seriesTypes.length; i++) {
        this.removeStyles(this.getSeriesElements(i, chart), chart);
      }
    },
    selectionChart: function selectionChart(element, index) {
      var chart = element.blazor__instance;

      if (!sf.base.isNullOrUndefined(chart)) {
        chart.currentMode = chart.selectionMode;
        chart.styleId = chart.element.id + '_ej2_chart_selection';
        this.selection(chart, index, this.findElements(chart, '', index));
      }
    },
    selectDataIndex: function selectDataIndex(element, chartSelectedDatas) {
      var _this = this;

      var currentInstance = element.blazor__instance;

      if (sf.base.isNullOrUndefined(currentInstance)) {
        return;
      }

      this.isAlreadySelected({
        type: "click"
      }, currentInstance);
      chartSelectedDatas.forEach(function (selectedIndex) {
        var query = "#" + element.id + "_Series_" + selectedIndex.series + "_Point_" + selectedIndex.point;

        _this.performSelection(selectedIndex, currentInstance, element.querySelector(query));
      });
    },
    focusTarget: function focusTarget(id) {
      var element;
      var className;

      if (id.indexOf("_chart_legend_") > -1) {
        element = this.getElement(id).parentElement;
        className = element.getAttribute("class");
        this.setTabIndex(this.getElement(this.id + "_chart_legend_translate_g").firstElementChild, this.getElement(this.id + "SeriesCollection").firstElementChild);
        element.setAttribute("tabindex", "0");

        if (className && className.indexOf("e-chart-focused") === -1) {
          className = className + " e-chart-focused";
        } else if (!className) {
          className = "e-chart-focused";
        }
      } else {
        element = this.getElement(id);
        className = "e-chart-focused";
      }

      element.setAttribute("tabindex", "0");
      element.setAttribute("class", className);
      element.focus();
    },
    focusChild: function focusChild(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");

      if (className && className.indexOf("e-chart-focused") === -1) {
        className = className + " e-chart-focused";
      } else if (!className) {
        className = "e-chart-focused";
      }

      element.setAttribute("class", className);
      element.focus();
      return element.id;
    },
    getActualIndex: function getActualIndex(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    },
    setTabIndex: function setTabIndex(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }

      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    },
    eventInterval: 80,
    dotnetref: {},
    getScrollEventArgs: function getScrollEventArgs(e, lastScrollbar) {
      if (lastScrollbar === void 0) {
        lastScrollbar = false;
      }

      var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
      var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
      var mouseXY = this.setScrollMouseXY(clientX, clientY, e.target['id'], lastScrollbar);
      var touches = e.touches; //pointerId

      var touchList = [];

      if (e.type.indexOf('touch') > -1) {
        for (var i = 0, length_2 = touches.length; i < length_2; i++) {
          touchList.push({
            pageX: touches[i].clientX,
            pageY: touches[i].clientY,
            pointerId: e.pointerId || 0
          });
        }
      }

      var id = e.target.id;
      id = id.indexOf('scrollBar') > -1 ? id : this.svgId;
      return {
        type: e.type,
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: mouseXY.mouseX,
        mouseY: mouseXY.mouseY,
        pointerType: e.pointerType,
        target: id,
        changedTouches: {
          clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
          clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
        },
        touches: touchList,
        pointerId: e.pointerId
      };
    },
    getScrollWheelArgs: function getScrollWheelArgs(e) {
      var mouseXY = this.setScrollMouseXY(e.clientX, e.clientY, e.currentTarget['id']);
      return {
        detail: e.detail,
        wheelDelta: e['wheelDelta'],
        target: e.currentTarget ? e.currentTarget['id'] : e.srcElement ? e.srcElement['id'] : e.target ? e.target['id'] : '',
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: mouseXY.mouseX,
        mouseY: mouseXY.mouseY,
        browserName: sf.base.Browser.info.name,
        isPointer: sf.base.Browser.isPointer
      };
    },
    svgId: null,
    setScrollMouseXY: function setScrollMouseXY(pageX, pageY, id, lastScrollbar) {
      if (lastScrollbar === void 0) {
        lastScrollbar = false;
      }

      this.svgId = !lastScrollbar ? id : this.svgId;

      if (!lastScrollbar && id.indexOf('_scrollBar_svg') === -1) {
        var chartId_1 = id.split('_scrollBar')[0];
        var splitId = id.split('_');
        this.svgId = chartId_1 + '_scrollBar_svg' + splitId[splitId.length - 1];
        this.dotnetref = this.dotnetrefCollection.find(function (item) {
          return chartId_1 === item.id;
        }).dotnetref;
      }

      var svgRect = this.getElement(this.svgId).getBoundingClientRect();
      var mouseX = pageX - Math.max(svgRect.left, 0);
      var mouseY = pageY - Math.max(svgRect.top, 0);
      return {
        mouseX: mouseX,
        mouseY: mouseY
      };
    },
    scrollMouseDown: function scrollMouseDown(event) {
      var evtArgs = this.getScrollEventArgs(event);
      this.dotnetref.invokeMethodAsync('ScrollMouseDown', evtArgs);
      return false;
    },
    scrollMouseMove: function scrollMouseMove(event) {
      if (this.scrollMouseMoveThreshold == null || new Date().getTime() - this.scrollMouseMoveThreshold > this.eventInterval) {
        this.scrollMouseMoveThreshold = new Date().getTime();
        var evtArgs = this.getScrollEventArgs(event);
        this.dotnetref.invokeMethodAsync('ScrollMouseMove', evtArgs);
      }

      return false;
    },
    scrollMouseUp: function scrollMouseUp(event) {
      var evtArgs = this.getScrollEventArgs(event);
      this.dotnetref.invokeMethodAsync('ScrollMouseUp', evtArgs);
      this.svgId = null;
      return false;
    },
    scrollMouseWheel: function scrollMouseWheel(event) {
      if (this.scrollbarMouseWheelThreshold == null || new Date().getTime() - this.scrollbarMouseWheelThreshold > this.eventInterval) {
        this.scrollbarMouseWheelThreshold = new Date().getTime();
        var evtArgs = this.getScrollWheelArgs(event);
        this.dotnetref.invokeMethodAsync('ScrollMouseWheel', evtArgs);
      }

      return false;
    },
    dotnetrefCollection: [],
    renderTooltip: function renderTooltip(tooltipOptions, elementId, tooltipModule, element) {
      var svgElement = document.getElementById(elementId + '_svg');
      var firstRender = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0 ? false : true;
      var options = JSON.parse(tooltipOptions);
      var currentInstance = element.blazor__instance;

      if (firstRender && !sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.tooltip = new sf.svgbase.Tooltip(options);
        currentInstance.tooltip.enableRTL = options.enableRTL;
        currentInstance.tooltip.appendTo('#' + elementId);

        currentInstance.tooltip.animationComplete = function (args) {
          if (args.tooltip.fadeOuted) {
            tooltipModule.invokeMethodAsync('TooltipAnimationComplete');
          }
        };
      } else if (!sf.base.isNullOrUndefined(currentInstance.tooltip)) {
        currentInstance.tooltip.location = new sf.svgbase.TooltipLocation(options.location.x, options.location.y);
        currentInstance.tooltip.content = options.content;
        currentInstance.tooltip.header = options.header;
        currentInstance.tooltip.offset = options.offset;
        currentInstance.tooltip.palette = options.palette;
        currentInstance.tooltip.shapes = options.shapes;
        currentInstance.tooltip.data = options.data;
        currentInstance.tooltip.template = options.template;
        currentInstance.tooltip.textStyle.color = options.textStyle.color || currentInstance.tooltip.textStyle.color;
        currentInstance.tooltip.textStyle.fontFamily = options.textStyle.fontFamily || currentInstance.tooltip.textStyle.fontFamily;
        currentInstance.tooltip.textStyle.fontStyle = options.textStyle.fontStyle || currentInstance.tooltip.textStyle.fontStyle;
        currentInstance.tooltip.textStyle.fontWeight = options.textStyle.fontWeight || currentInstance.tooltip.textStyle.fontWeight;
        currentInstance.tooltip.textStyle.opacity = options.textStyle.opacity || currentInstance.tooltip.textStyle.opacity;
        currentInstance.tooltip.textStyle.size = options.textStyle.size || currentInstance.tooltip.textStyle.size;
        currentInstance.tooltip.isNegative = options.isNegative;
        currentInstance.tooltip.clipBounds = new sf.svgbase.TooltipLocation(options.clipBounds.x, options.clipBounds.y);
        currentInstance.tooltip.arrowPadding = options.arrowPadding;
        currentInstance.tooltip.dataBind();
      }
    },
    fadeOut: function fadeOut(element) {
      if (!element || sf.base.isNullOrUndefined(element.blazor__instance) || !sf.base.isNullOrUndefined(element.blazor__instance) && sf.base.isNullOrUndefined(element.blazor__instance.tooltip)) {
        return;
      }

      this.removeTooltipCommentElement(element);
      element.blazor__instance.tooltip.fadeOut();
    },
    removeTooltipCommentElement: function removeTooltipCommentElement(chartInstance) {
      var tooltipDivElement = this.getElement(chartInstance.blazor__instance.tooltip.element.id);

      if (tooltipDivElement && !chartInstance.blazor__instance.isRemoveCommentElement && tooltipDivElement.childNodes.length > 1) {
        var tooltipElements = tooltipDivElement.childNodes;
        var commentElements = [];

        for (var i = 0; i < tooltipElements.length; i++) {
          if (tooltipElements[i].nodeName.match('#comment') || tooltipElements[i].nodeName.match('#text')) {
            commentElements.push(tooltipElements[i]);
          }
        }

        for (var _i = 0, commentElements_1 = commentElements; _i < commentElements_1.length; _i++) {
          var element = commentElements_1[_i];
          sf.base.remove(element);
          chartInstance.blazor__instance.isRemoveCommentElement = true;
        }
      }
    },
    getParentElementBoundsById: function getParentElementBoundsById(id) {
      var element = document.getElementById(id);

      if (element) {
        element.style.width = '100%';
        element.style.height = '100%';
        var elementRect = element.getBoundingClientRect();
        return {
          width: elementRect.width || element.clientWidth || element.offsetWidth,
          height: elementRect.height || element.clientHeight || element.offsetHeight,
          left: elementRect.left,
          top: elementRect.top,
          right: elementRect.right,
          bottom: elementRect.bottom
        };
      }

      return {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
    },
    getElementBoundsById: function getElementBoundsById(id, isSetId) {
      if (isSetId === void 0) {
        isSetId = true;
      }

      if (isSetId) {
        this.id = id;
      }

      var element = document.getElementById(id);

      if (element) {
        var elementRect = element.getBoundingClientRect();
        return {
          width: element.clientWidth || element.offsetWidth,
          height: element.clientHeight || element.offsetHeight,
          left: elementRect.left,
          top: elementRect.top,
          right: elementRect.right,
          bottom: elementRect.bottom
        };
      }

      return {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
    },
    getBrowserDeviceInfo: function getBrowserDeviceInfo() {
      return {
        browserName: sf.base.Browser.info.name,
        isPointer: sf.base.Browser.isPointer,
        isDevice: sf.base.Browser.isDevice,
        isTouch: sf.base.Browser.isTouch,
        isIos: sf.base.Browser.isIos || sf.base.Browser.isIos7
      };
    },
    setZoomingCipPath: function setZoomingCipPath(seriesCollection, indicator, clipUrl) {
      var seriesEle = document.getElementById(seriesCollection);
      var indicatorEle = document.getElementById(indicator);

      if (seriesEle) {
        seriesEle.setAttribute('clip-path', clipUrl);
      }

      if (indicatorEle) {
        seriesEle.setAttribute('clip-path', clipUrl);
      }
    },
    setZoomingElementAttributes: function setZoomingElementAttributes(translate, category, seriesG, errorbarG, symbolG, textG, shapeG, element) {
      if (category === 'Indicator' && seriesG && seriesG.parentElement) {
        seriesG.parentElement.setAttribute('transform', translate);
      }

      if (seriesG) {
        seriesG.setAttribute('transform', translate);
      }

      if (errorbarG) {
        errorbarG.setAttribute('transform', translate);
      }

      if (symbolG) {
        symbolG.setAttribute('transform', translate);
      }

      if (textG) {
        textG.setAttribute('visibility', 'hidden');
      }

      if (shapeG) {
        shapeG.setAttribute('visibility', 'hidden');
      }

      if (element) {
        element.style.visibility = 'hidden';
      }
    },
    measureBreakText: function measureBreakText(text, size, color, fontFamily, fontWeight, fontStyle, opacity) {
      var font = {
        color: color,
        size: size,
        fontFamily: fontFamily,
        fontWeight: fontWeight,
        fontStyle: fontStyle,
        opacity: parseInt(opacity, 10)
      };
      return sf.svgbase.measureText(text, font);
    },
    getAllCharacters: function getAllCharacters() {
      var charCollection = [];

      for (var i = 33; i < 591; i++) {
        charCollection.push(String.fromCharCode(i));
      }

      return charCollection;
    },
    measureText: function measureText(text, fontWeight, fontStyle, fontFamily) {
      var textObject = document.getElementById('sfchartmeasuretext');

      if (textObject === null) {
        textObject = sf.base.createElement('text', {
          id: 'sfchartmeasuretext'
        });
        document.body.appendChild(textObject);
      }

      if (text === ' ') {
        text = '&nbsp;';
      }

      textObject.innerHTML = text;
      textObject.style.position = 'fixed';
      textObject.style.fontSize = '100px';
      textObject.style.fontWeight = fontWeight;
      textObject.style.fontStyle = fontStyle;
      textObject.style.fontFamily = fontFamily;
      textObject.style.visibility = 'hidden';
      textObject.style.top = '-100';
      textObject.style.left = '0';
      textObject.style.whiteSpace = 'nowrap';
      textObject.style.lineHeight = 'normal';
      return {
        Width: textObject.clientWidth,
        Height: textObject.clientHeight
      };
    },
    getCharCollectionSize: function getCharCollectionSize(fontkeys) {
      var charSizeList = [];
      var charSize;
      var tempSizeList = {};
      var charList = this.getAllCharacters();
      var charLength = charList.length;
      var fontKeysLength = fontkeys.length;

      for (var i = 0; i < fontKeysLength; i++) {
        var fontValues = fontkeys[i].split('_');
        var fontWeight = fontValues[0];
        var fontStyle = fontValues[1];
        var fontFamily = fontValues[2];

        for (var j = 0; j < charLength; j++) {
          charSize = this.measureText(charList[j], fontWeight, fontStyle, fontFamily);
          tempSizeList[charList[j]] = {
            X: charSize.Width,
            Y: charSize.Height
          };
        }

        charSizeList.push(tempSizeList);
      }

      var result = JSON.stringify(charSizeList);
      return result;
    },
    getCharSizeByFontKeys: function getCharSizeByFontKeys(fontkeys) {
      var charSizeList = {};
      var fontKeysLength = fontkeys.length;
      var fontValues = [];
      var charSize;

      for (var i = 0; i < fontKeysLength; i++) {
        fontValues = fontkeys[i].split('_');
        charSize = this.measureText(fontValues[0], fontValues[1], fontValues[2], fontValues[3]);
        charSizeList[fontkeys[i]] = {
          X: charSize.Width,
          Y: charSize.Height
        };
      }

      var result = JSON.stringify(charSizeList);
      return result;
    },
    getElementRect: function getElementRect(id) {
      var element = document.getElementById(id);
      var rect = element.getBoundingClientRect();
      sf.base.remove(element);
      return {
        Left: rect.left,
        Right: rect.right,
        Top: rect.top,
        Bottom: rect.bottom,
        Width: rect.width,
        Height: rect.height
      };
    },
    getElement: function getElement(id) {
      return document.getElementById(id);
    },
    drawTrackBall: function drawTrackBall(svgId, option, tagName, className, clipPath, transform) {
      var parentElement = this.getElement(svgId);

      if (parentElement) {
        var childElement = document.createElementNS('http://www.w3.org/2000/svg', tagName);
        var keys = Object.keys(option);
        var key = '';

        for (var i = 0; i < keys.length; i++) {
          key = keys[i] === 'strokeWidth' ? 'stroke-width' : keys[i] === 'strokeDashArray' ? 'stroke-dashArray' : keys[i] === 'direction' ? 'd' : keys[i];
          childElement.setAttribute(key, option[keys[i]]);
        }

        childElement.setAttribute('class', className);
        childElement.setAttribute('clip-path', clipPath);
        childElement.setAttribute('transform', transform);
        parentElement.appendChild(childElement);
      }
    },
    removeHighLightedMarker: function removeHighLightedMarker(className) {
      var elements = document.getElementsByClassName(className);

      for (var i = 0, len = elements.length; i < len; i++) {
        sf.base.remove(elements[0]);
      }
    },
    setAttribute: function setAttribute(id, attribute, value) {
      var element = this.getElement(id);

      if (element) {
        element.setAttribute(attribute, value);
      }
    },
    createTooltip: function createTooltip(id, text, top, left, fontSize) {
      var tooltip = document.getElementById(id);
      var style = 'top:' + ((window.scrollY || 0) + top).toString() + 'px;' + 'left:' + left.toString() + 'px;' + 'color:black !important; ' + 'background:#FFFFFF !important; ' + 'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';

      if (!tooltip) {
        tooltip = sf.base.createElement('div', {
          id: id,
          innerHTML: '&nbsp;' + text + '&nbsp;',
          styles: style
        });
        document.body.appendChild(tooltip);
      } else {
        tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');
        tooltip.setAttribute('styles', style);
      }
    },
    removeElement: function removeElement(id) {
      var element = this.getElement(id);

      if (element) {
        sf.base.remove(element);
      }
    },
    applySelection: function applySelection(id, color) {
      var elements = document.getElementById(id);
      var childNodes;

      if (elements && elements.childNodes) {
        childNodes = elements.childNodes;

        for (var i = 1, length_3 = childNodes.length; i < length_3; i++) {
          if (childNodes[i] && childNodes[i].tagName !== 'rect' && childNodes[i].setAttribute) {
            childNodes[i].setAttribute('fill', color);
          }
        }
      }
    },
    getAndSetTextContent: function getAndSetTextContent(id, get, value) {
      var element = document.getElementById(id);

      if (element) {
        if (get) {
          return element.textContent;
        } else {
          element.textContent = value;
        }
      }

      return null;
    },
    doProgressiveAnimation: function doProgressiveAnimation(id, clipId, duration, delay, strokeDashArray) {
      var clipElement = this.getElement(clipId);
      var path = this.getElement(id);
      var animation = new sf.base.Animation({});
      var pathLength = path.getTotalLength();
      var currentTime;
      path.setAttribute('visibility', 'hidden');
      animation.animate(path, {
        duration: duration + delay,
        delay: delay,
        progress: function progress(args) {
          clipElement.setAttribute('visibility', 'visible');

          if (args.timeStamp >= args.delay) {
            path.setAttribute('visibility', 'visible');
            currentTime = Math.abs(Math.round((args.timeStamp - args.delay) * pathLength / args.duration));
            path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);
          }
        },
        end: function end() {
          path.setAttribute('stroke-dasharray', strokeDashArray);
        }
      });
    },
    linear: function linear(currentTime, startValue, endValue, duration) {
      return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
    },
    doLinearAnimation: function doLinearAnimation(id, duration, delay, isInverted) {
      var clipRect = this.getElement(id);
      var animation = new sf.base.Animation({});
      var effect = this.linear;
      var elementHeight = +clipRect.getAttribute('height');
      var elementWidth = +clipRect.getAttribute('width');
      var xCenter = +clipRect.getAttribute('x');
      var yCenter = isInverted ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') : +clipRect.getAttribute('y');
      var value;
      animation.animate(clipRect, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          if (args.timeStamp >= args.delay) {
            clipRect.setAttribute('visibility', 'visible');

            if (isInverted) {
              value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
              clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(1,' + value / elementHeight + ') translate(' + -xCenter + ' ' + -yCenter + ')');
            } else {
              value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
              clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(' + value / elementWidth + ', 1) translate(' + -xCenter + ' ' + -yCenter + ')');
            }
          }
        },
        end: function end() {
          clipRect.setAttribute('transform', 'translate(0,0)');
        }
      });
    },
    filterCommentElement: function filterCommentElement(id) {
      var element = this.getElement(id);

      if (!element) {
        return null;
      }

      var groupElement = element.childNodes;
      var pathElement = [];

      for (var i = 0; i < groupElement.length; i++) {
        if (!groupElement[i].nodeName.match('#comment')) {
          pathElement.push(groupElement[i]);
        }
      }

      return pathElement;
    },
    doInitialAnimation: function doInitialAnimation(info) {
      for (var infoIndex = 0; infoIndex < info.length; infoIndex++) {
        switch (info[infoIndex].type) {
          case 'Rect':
            var seriesClipPath = this.getElement(info[infoIndex].clipPathId);
            var seriesPathElement = this.filterCommentElement(info[infoIndex].elementId);

            for (var i = 0; i < info[infoIndex].pointIndex.length; i++) {
              this.doRectAnimation(seriesPathElement[info[infoIndex].pointIndex[i]], seriesClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[i], info[infoIndex].pointY[i], info[infoIndex].pointWidth[i], info[infoIndex].pointHeight[i], info[infoIndex].isInvertedAxis);
            }

            break;

          case 'Progressive':
            this.doProgressiveAnimation(info[infoIndex].elementId, info[infoIndex].clipPathId, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].strokeDashArray);
            break;

          case 'Linear':
            this.doLinearAnimation(info[infoIndex].elementId, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].isInvertedAxis);
            break;

          case 'Marker':
            var markerClipPath = this.getElement(info[infoIndex].clipPathId);
            var markerElement = this.filterCommentElement(info[infoIndex].elementId);

            for (var i = 0; i < info[infoIndex].pointIndex.length; i++) {
              this.doMarkerAnimate(markerElement[info[infoIndex].pointIndex[i]], markerClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[i], info[infoIndex].pointY[i]);
            }

            break;

          case 'PolarRadar':
            var polarseriesClipPath = this.getElement(info[infoIndex].clipPathId);
            var polarseriesPathElement = this.filterCommentElement(info[infoIndex].elementId);

            for (var i = 0; i < polarseriesPathElement.length; i++) {
              this.doPolarRadarAnimation(polarseriesPathElement[i], polarseriesClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[0], info[infoIndex].pointY[0]);
            }

            break;
        }

        if (!sf.base.isNullOrUndefined(info[infoIndex].markerInfo)) {
          var markerClipPath = this.getElement(info[infoIndex].markerInfo.markerClipPathId);
          var markerElement = this.filterCommentElement(info[infoIndex].markerInfo.markerElementId);

          for (var i = 0; i < info[infoIndex].markerInfo.pointIndex.length; i++) {
            this.doMarkerAnimate(markerElement[info[infoIndex].markerInfo.pointIndex[i]], markerClipPath, 200, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].markerInfo.pointX[i], info[infoIndex].markerInfo.pointY[i]);

            if (info[infoIndex].markerInfo.lowPointIndex.length > 0) {
              this.doMarkerAnimate(markerElement[info[infoIndex].markerInfo.lowPointIndex[i]], markerClipPath, 200, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].markerInfo.lowPointX[i], info[infoIndex].markerInfo.lowPointY[i]);
            }
          }
        }

        if (!sf.base.isNullOrUndefined(info[infoIndex].dataLabelInfo)) {
          if (info[infoIndex].dataLabelInfo.templateId.length === 0) {
            this.doDataLabelAnimation(info[infoIndex].dataLabelInfo.shapeGroupId, info[infoIndex].dataLabelInfo.textGroupId, '', info[infoIndex].clipPathId, 200, info[infoIndex].duration + info[infoIndex].delay);
          } else {
            for (var i = 0; i < info[infoIndex].dataLabelInfo.templateId.length; i++) {
              this.doDataLabelAnimation('', '', info[infoIndex].dataLabelInfo.templateId[i], '', 200, info[infoIndex].duration + info[infoIndex].delay);
            }
          }
        }

        if (!sf.base.isNullOrUndefined(info[infoIndex].errorBarInfo)) {
          this.doErrorBarAnimation(info[infoIndex].errorBarInfo.errorBarElementId, info[infoIndex].errorBarInfo.errorBarClipPathId, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].isInvertedAxis);
        }
      }
    },
    doDynamicAnimation: function doDynamicAnimation(pathInfo, rectInfo, textInfo) {
      for (var pathIndex = 0; pathIndex < pathInfo.length; pathIndex++) {
        if (!sf.base.isNullOrUndefined(pathInfo[pathIndex].previousDir) && pathInfo[pathIndex].previousDir !== '' && !sf.base.isNullOrUndefined(pathInfo[pathIndex].currentDir) && pathInfo[pathIndex].currentDir !== '') {
          this.pathAnimation(pathInfo[pathIndex].id, pathInfo[pathIndex].currentDir, true, pathInfo[pathIndex].previousDir, 300);
        }
      }

      for (var rectIndex = 0; rectIndex < rectInfo.length; rectIndex++) {
        this.animateRectElement(rectInfo[rectIndex].id, 0, 300, rectInfo[rectIndex].currentRect, rectInfo[rectIndex].previousRect);
      }

      for (var textIndex = 0; textIndex < textInfo.length; textIndex++) {
        this.animateRedrawElement(textInfo[textIndex].id, 300, textInfo[textIndex].preLocationX, textInfo[textIndex].preLocationY, textInfo[textIndex].curLocationX, textInfo[textIndex].curLocationY, textInfo[textIndex].x, textInfo[textIndex].y);
      }
    },
    doRectAnimation: function doRectAnimation(element, clipPathElement, duration, delay, centerX, centerY, elementWidth, elementHeight, isInverted) {
      var effect = this.linear;
      var value;

      if (!sf.base.isNullOrUndefined(element)) {
        element.setAttribute('visibility', 'hidden');
        new sf.base.Animation({}).animate(element, {
          duration: duration,
          delay: delay,
          progress: function progress(args) {
            clipPathElement.setAttribute('visibility', 'visible');

            if (args.timeStamp >= args.delay) {
              element.setAttribute('visibility', 'visible');

              if (!isInverted) {
                elementHeight = elementHeight ? elementHeight : 1;
                value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(1,' + value / elementHeight + ') translate(' + -centerX + ' ' + -centerY + ')');
              } else {
                elementWidth = elementWidth ? elementWidth : 1;
                value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + value / elementWidth + ', 1) translate(' + -centerX + ' ' + -centerY + ')');
              }
            }
          },
          end: function end() {
            element.setAttribute('transform', 'translate(0,0)');
          }
        });
      }
    },
    doMarkerAnimate: function doMarkerAnimate(element, clipPathElement, duration, delay, centerX, centerY) {
      var height = 0;

      if (!element) {
        return;
      }

      element.setAttribute('visibility', 'hidden');
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          clipPathElement.setAttribute('visibility', 'visible');

          if (args.timeStamp > args.delay) {
            element.setAttribute('visibility', 'visible');
            height = (args.timeStamp - args.delay) / args.duration;
            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + height + ') translate(' + -centerX + ' ' + -centerY + ')');
          }
        },
        end: function end() {
          element.setAttribute('visibility', '');
        }
      });
    },
    doPolarRadarAnimation: function doPolarRadarAnimation(element, clipPathElement, duration, delay, chartcenterX, chartcenterY) {
      var elementHeight = 0;
      element.setAttribute('visibility', 'hidden');
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          clipPathElement.setAttribute('visibility', 'visible');

          if (args.timeStamp > args.delay) {
            element.setAttribute('visibility', 'visible');
            elementHeight = (args.timeStamp - args.delay) / args.duration;
            element.setAttribute('transform', 'translate(' + chartcenterX + ' ' + chartcenterY + ') scale(' + elementHeight + ') translate(' + -chartcenterX + ' ' + -chartcenterY + ')');
          }
        },
        end: function end() {
          element.setAttribute('visibility', 'visible');
          element.removeAttribute('transform');
        }
      });
    },
    templateAnimate: function templateAnimate(element, delay, duration, name, isRemove, clipElement) {
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        name: name,
        progress: function progress(args) {
          if (clipElement) {
            clipElement.setAttribute('visibility', 'visible');
          }

          args.element.style.visibility = 'visible';
        },
        end: function end(args) {
          if (isRemove) {
            sf.base.remove(args.element);
          } else {
            args.element.style.visibility = 'visible';
          }
        }
      });
    },
    doDataLabelAnimation: function doDataLabelAnimation(shapeId, textId, tempId, clipId, duration, delay) {
      var shapeElements = this.filterCommentElement(shapeId);
      var textElements = this.filterCommentElement(textId);
      var clipPathElement = this.getElement(clipId);
      var tempElement = this.getElement(tempId);
      var centerX;
      var centerY;
      var length = tempElement ? 1 : textElements.length;
      var element;

      for (var i = 0; i < length; i++) {
        if (tempElement) {
          tempElement.style.visibility = 'hidden';
          this.templateAnimate(tempElement, delay, duration, 'ZoomIn');
        } else {
          element = textElements[i];
          centerX = +element.getAttribute('x') + +element.getAttribute('width') / 2;
          centerY = +element.getAttribute('y') + +element.getAttribute('height') / 2;
          this.doMarkerAnimate(textElements[i], clipPathElement, duration, delay, centerX, centerY);

          if (shapeElements[i]) {
            element = shapeElements[i];
            centerX = +element.getAttribute('x') + +element.getAttribute('width') / 2;
            centerY = +element.getAttribute('y') + +element.getAttribute('height') / 2;
            this.doMarkerAnimate(shapeElements[i], clipPathElement, duration, delay, centerX, centerY);
          }
        }
      }
    },
    pathAnimation: function pathAnimation(id, direction, redraw, previousDirection, animateDuration) {
      var _this = this;

      var element = this.getElement(id);

      if (!redraw || element == null) {
        return null;
      }

      var duration = 300;

      if (animateDuration) {
        duration = animateDuration;
      }

      var startDirections = previousDirection || element.getAttribute('d');
      var splitDirections = startDirections.split(/(?=[LMCZAQ])/);
      var endDirections = direction.split(/(?=[LMCZAQ])/);
      var currentDireciton;
      var startPath = [];
      var endPath = [];
      var c;
      var end;
      element.setAttribute('d', startDirections);
      new sf.base.Animation({}).animate(sf.base.createElement('div'), {
        duration: duration,
        progress: function progress(args) {
          currentDireciton = '';
          splitDirections.map(function (directions, index) {
            startPath = directions.split(' ');
            endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;

            if (startPath[0] === 'Z') {
              currentDireciton += 'Z' + ' ';
            } else {
              currentDireciton += startPath[0] + ' ' + _this.linear(args.timeStamp, +startPath[1], +endPath[1] - +startPath[1], args.duration) + ' ' + _this.linear(args.timeStamp, +startPath[2], +endPath[2] - +startPath[2], args.duration) + ' ';
            }

            if (startPath[0] === 'C' || startPath[0] === 'Q') {
              c = 3;
              end = startPath[0] === 'Q' ? 4 : 6;

              while (c < end) {
                currentDireciton += _this.linear(args.timeStamp, +startPath[c], +endPath[c] - +startPath[c], args.duration) + ' ' + _this.linear(args.timeStamp, +startPath[++c], +endPath[c] - +startPath[c], args.duration) + ' ';
                ++c;
              }
            }

            if (startPath[0] === 'A') {
              currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' + _this.linear(args.timeStamp, +startPath[6], +endPath[6] - +startPath[6], args.duration) + ' ' + _this.linear(args.timeStamp, +startPath[7], +endPath[7] - +startPath[7], args.duration) + ' ';
            }
          });
          element.setAttribute('d', currentDireciton);
        },
        end: function end() {
          element.setAttribute('d', direction);
        }
      });
    },
    getPreviousDirection: function getPreviousDirection(id) {
      var element = this.getElement(id);
      var previousDirection = element ? element.getAttribute('d') : null;
      return previousDirection;
    },
    getPreviousLocation: function getPreviousLocation(id, circlePath) {
      var element = this.getElement(id);
      var x = element ? +element.getAttribute(circlePath + 'x') : 0;
      var y = element ? +element.getAttribute(circlePath + 'y') : 0;
      return {
        X: x,
        Y: y
      };
    },
    animateRectElement: function animateRectElement(element, delay, duration, currentRect, previousRect) {
      var _this = this;

      var setStyle = function setStyle(rect) {
        element.setAttribute('x', rect.x + '');
        element.setAttribute('y', rect.y + '');
        element.setAttribute('width', rect.width + '');
        element.setAttribute('height', rect.height + '');
      };

      new sf.base.Animation({}).animate(sf.base.createElement('div'), {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          setStyle(new sf.svgbase.Rect(_this.linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), _this.linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), _this.linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), _this.linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));
        },
        end: function end() {
          setStyle(currentRect);
        }
      });
    },
    animateRedrawElement: function animateRedrawElement(elementId, duration, startX, startY, endX, endY, x, y) {
      var _this = this;

      if (x === void 0) {
        x = 'x';
      }

      if (y === void 0) {
        y = 'y';
      }

      var element = this.getElement(elementId);

      if (!element) {
        return null;
      }

      var isDiv = element.tagName === 'DIV';

      var setStyle = function setStyle(xValue, yValue) {
        if (isDiv) {
          element.style[x] = xValue + 'px';
          element.style[y] = yValue + 'px';
        } else {
          element.setAttribute(x, xValue + '');
          element.setAttribute(y, yValue + '');
        }
      };

      setStyle(startX, startY);
      new sf.base.Animation({}).animate(sf.base.createElement('div'), {
        duration: duration,
        progress: function progress(args) {
          setStyle(_this.linear(args.timeStamp, startX, endX - startX, args.duration), _this.linear(args.timeStamp, startY, endY - startY, args.duration));
        },
        end: function end() {
          setStyle(endX, endY);
        }
      });
    },
    appendChildElement: function appendChildElement(parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration) {
      if (isAnimate === void 0) {
        isAnimate = false;
      }

      if (x === void 0) {
        x = 'x';
      }

      if (y === void 0) {
        y = 'y';
      }

      if (forceAnimate === void 0) {
        forceAnimate = false;
      }

      if (isRect === void 0) {
        isRect = false;
      }

      if (previousRect === void 0) {
        previousRect = null;
      }

      var existChild = parent.querySelector('#' + childElement.id);
      var element = existChild || this.getElement(childElement.id);
      var child = childElement;
      var duration = animateDuration ? animateDuration : 300;

      if (redraw && isAnimate && element) {
        start = start || (element.tagName === 'DIV' ? new sf.svgbase.TooltipLocation(+element.style[x].split('px')[0], +element.style[y].split('px')[0]) : new sf.svgbase.TooltipLocation(+element.getAttribute(x), +element.getAttribute(y)));

        if (direction !== '' && direction !== null) {
          this.pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);
        } else if (isRect && previousRect) {
          this.animateRectElement(child, 0, duration, new sf.svgbase.Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);
        } else {
          var end = child.tagName === 'DIV' ? new sf.svgbase.TooltipLocation(+child.style[x].split('px')[0], +child.style[y].split('px')[0]) : new sf.svgbase.TooltipLocation(+child.getAttribute(x), +child.getAttribute(y));
          this.animateRedrawElement(child, duration, start, end, x, y);
        }
      } else if (redraw && isAnimate && !element && forceAnimate) {
        this.templateAnimate(child, 0, 600, 'FadeIn');
      }
    },
    processAppendChild: function processAppendChild(parentId, childId, locationX, locationY, rectX, rectY, rectWidth, rectHeight, redraw, isAnimate, x, y, direction, forceAnimate, isRect, animateDuration) {
      if (isAnimate === void 0) {
        isAnimate = false;
      }

      if (x === void 0) {
        x = 'x';
      }

      if (y === void 0) {
        y = 'y';
      }

      if (forceAnimate === void 0) {
        forceAnimate = false;
      }

      if (isRect === void 0) {
        isRect = false;
      }

      var parentElement = this.getElement(parentId);
      var childElement = this.getElement(childId);
      var start = new sf.svgbase.TooltipLocation(locationX, locationY);
      var rect = new sf.svgbase.Rect(rectX, rectY, rectWidth, rectHeight);
      this.appendChildElement(parentElement, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, rect, animateDuration);
    },
    createStyleElement: function createStyleElement(styleId, styleInnerHTML) {
      document.body.appendChild(sf.base.createElement('style', {
        id: styleId,
        innerHTML: styleInnerHTML
      }));
    },
    isLassoId: function isLassoId(x, y) {
      var lassoEle = document.elementFromPoint(x, y);
      return lassoEle ? lassoEle.id : '';
    },
    doErrorBarAnimation: function doErrorBarAnimation(id, clipId, delay, isInverted) {
      var errorBarElements = this.filterCommentElement(id);
      var clipElement = this.getElement(clipId);

      if (!errorBarElements) {
        return null;
      }

      var j = 1;

      while (j < errorBarElements.length) {
        errorBarElements[j].style.visibility = 'hidden';
        this.templateAnimate(errorBarElements[j], delay, 350, isInverted ? 'SlideLeftIn' : 'SlideBottomIn', false, clipElement);
        j++;
      }
    },
    getTemplateSize: function getTemplateSize(id) {
      var element = this.getElement(id);

      if (element) {
        return {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
      }

      return null;
    },
    resizeBound: {},
    resize: {},
    chartResize: function chartResize(dotnetrefCollection, e) {
      var _this = this;

      if (this.resize) {
        clearTimeout(this.resize);
      }

      this.resize = setTimeout(function () {
        var count = dotnetrefCollection.length;
        var tempDotnetref;
        var id;
        var element;
        var offsetSizeCollection = {};

        for (var i = 0; i < count; i++) {
          tempDotnetref = dotnetrefCollection[i].dotnetref;
          id = dotnetrefCollection[i].id;

          if (id.indexOf('_stockChart_') < 0 && document.getElementById(id + "_svg")) {
            element = document.getElementById(id + "_svg");
            element.style.display = "none";
          }
        }

        for (var i = 0; i < count; i++) {
          tempDotnetref = dotnetrefCollection[i].dotnetref;
          id = dotnetrefCollection[i].id;

          if (id.indexOf('_stockChart_') < 0 && document.getElementById(id)) {
            element = document.getElementById(id);
            offsetSizeCollection[id] = {
              Dotnetref: tempDotnetref,
              Width: element.clientWidth || element.offsetWidth,
              Height: element.clientHeight || element.offsetHeight
            };
          }
        }

        for (var key in offsetSizeCollection) {
          tempDotnetref = offsetSizeCollection[key].Dotnetref;
          element = document.getElementById(key + "_svg");
          element.style.display = "";
          tempDotnetref.invokeMethodAsync('OnChartResize', JSON.stringify({
            Width: offsetSizeCollection[key].Width,
            Height: offsetSizeCollection[key].Height
          }));
        }

        clearTimeout(_this.resize);
      }, 500);
      return false;
    },
    getDatalabelTemplateSize: function getDatalabelTemplateSize(templateIdCollection) {
      var templateSizeList = [];
      var templateSize;
      var templateIdLength = templateIdCollection.length;

      for (var i = 0; i < templateIdLength; i++) {
        templateSize = this.getElementBoundsById(templateIdCollection[i], false);
        templateSizeList.push({
          X: templateSize.width,
          Y: templateSize.height
        });
      }

      return JSON.stringify(templateSizeList);
    },
    setSvgDimensions: function setSvgDimensions(chartSVG, width, height) {
      chartSVG.setAttribute("width", width);
      chartSVG.setAttribute("height", height);
    },
    findDOMElement: function findDOMElement(id) {
      return document.getElementById(id);
    },
    calculateSelectedElements: function calculateSelectedElements(e, element) {
      if (sf.base.isNullOrUndefined(e.target)) {
        return;
      }

      var target = e.target;
      var charts = element.blazor__instance;
      target = this.findDOMElement(this.findDOMElementFromDataLabel(target.id, charts));

      if (charts.selectionMode === 'None' && charts.highlightMode === 'None' || sf.base.isNullOrUndefined(target) && target.id.indexOf(charts.element.id + '_') === -1) {
        return;
      }

      if (e.type === 'mousemove' || e.type === 'pointermove') {
        if (target === null && target.id.indexOf('Trackball') > -1) {
          target = this.findDOMElement(target.id.split('_Trackball')[0]);
        }

        if (target.hasAttribute('class') && (target.getAttribute('class').indexOf('highlight') > -1 || target.getAttribute('class').indexOf('selection') > -1)) {
          return;
        }
      }

      this.isAlreadySelected(e, charts);

      if (target.id.indexOf('_Series_') > -1) {
        var element_1;

        if (target.id.indexOf('_Trackball_1') > -1) {
          element_1 = this.findDOMElement(target.id.split('_Trackball_')[0] + '_Symbol');
          element_1 = sf.base.isNullOrUndefined(element_1) ? this.findDOMElement(target.id.split('_Trackball_')[0]) : element_1;
        } else if (target.id.indexOf('_Trackball_0') > -1) {
          return null;
        }

        this.performSelection(this.indexFinder(target.id), charts, element_1 || target);
      }
    },
    generateStyle: function generateStyle(targetId, chart) {
      var dataPoint = this.findDOMElement(targetId).getAttribute('data-point');
      var parentElement;

      if (targetId.indexOf("SeriesGroup") > -1 || targetId.indexOf("SymbolGroup") > -1) {
        parentElement = document.getElementById(targetId).querySelectorAll("path,ellipse");
        dataPoint = parentElement.length > 0 ? parentElement[0].getAttribute('data-point') : null;
      }

      if (!dataPoint) {
        return 'undefined';
      }

      var dataPointArray = dataPoint.split(",");
      var seriesType = dataPointArray[3];

      if (seriesType) {
        if (chart.styleId.indexOf('selection') > 1 && chart.selectionMode !== 'None') {
          chart.unSelected = dataPointArray[7] || chart.unSelected;
        }

        if (chart.styleId.indexOf('highlight') > 0 && chart.highlightMode !== 'None') {
          chart.unSelected = dataPointArray[5] || chart.unSelected;
        }

        return dataPointArray[6] || chart.styleId + '_series' + dataPointArray[4];
      }

      return 'undefined';
    },
    findDOMElementFromDataLabel: function findDOMElementFromDataLabel(id, charts) {
      if (id.indexOf('Text') > -1 && id.indexOf('Series') > -1) {
        var primId = id.split('_Text_')[0];

        if (this.isRectSeries(charts.seriesTypes[id.split("_Series_")[1].split("_")[0]]) || charts.seriesTypes[0] === 'Bubble' || charts.seriesTypes[0] === 'Scatter') {
          return primId;
        } else {
          return primId.slice(0, primId.length) + '_Symbol ';
        }
      }

      return id;
    },
    indexFinder: function indexFinder(id) {
      var ids = ['NaN', 'NaN'];

      if (id.indexOf('_Point_') > -1) {
        ids = id.split('_Series_')[1].split('_Point_');

        if (ids[1].indexOf('Text') > -1) {
          ids[1] = ids[1].split('_Text_')[0];
        }
      } else if (id.indexOf('_shape_') > -1 && !id.indexOf('_legend_')) {
        ids = id.split('_shape_');
        ids[0] = ids[1];
      } else if (id.indexOf('_text_') > -1 && !id.indexOf('_legend_')) {
        ids = id.split("_text_");

        if (id.indexOf("datalabel") > -1) {
          ids[0] = ids[0].split("_Series_")[1];
        } else {
          ids[0] = ids[1];
        }
      } else if (id.indexOf("Series") > -1 && !(id.indexOf("points") > -1)) {
        ids[0] = id.split("_Series_")[1].split("_")[0];
      }

      return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    },
    addOrRemoveIndex: function addOrRemoveIndex(indexes, index, charts, isAdd) {
      for (var i = 0; i < indexes.length; i++) {
        if (this.toEquals(indexes[i], index, charts.isSeriesMode, charts)) {
          indexes.splice(i, 1);
          i--;
        }
      }

      if (isAdd) {
        indexes.push(index);
      }
    },
    toEquals: function toEquals(first, second, checkSeriesOnly, chart) {
      return (first.series === second.series || chart.currentMode === 'Cluster' && !checkSeriesOnly) && (checkSeriesOnly || first.point === second.point);
    },
    removeSvgClass: function removeSvgClass(element, className) {
      var elementClassName = !sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.getAttribute('class')) ? element.getAttribute('class') : "";

      if (elementClassName.indexOf(className) > -1) {
        element.setAttribute('class', elementClassName.replace(className, ''));
      }
    },
    getSelectionClass: function getSelectionClass(id, chart) {
      return this.generateStyle(id, chart);
    },
    removeStyles: function removeStyles(elements, chart) {
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];

        if (element !== null) {
          var targetElement = element;
          var dataPoint = this.findDOMElement(targetElement.id).getAttribute('data-point');
          var dataPointArray = dataPoint ? dataPoint.split(",") : [];
          this.removeSvgClass(element, this.getSelectionClass(element.id, chart));

          if (chart.highlightPattern === 'None' && chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
            if (element.id.indexOf('Group') > 0) {
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].setAttribute('fill', dataPointArray[2]);
              }
            } else {
              element.setAttribute('fill', dataPointArray[2]);
            }
          }
        }
      }
    },
    findTrackballElements: function findTrackballElements(selectedElements, className, chart) {
      var trackballElements;
      var elements;

      for (var i = 0; i < selectedElements.length; i++) {
        if (!sf.base.isNullOrUndefined(selectedElements[i])) {
          trackballElements = !sf.base.isNullOrUndefined(selectedElements[i].parentNode) ? [].slice.call(selectedElements[0].parentNode.querySelectorAll('.' + className)) : [];

          if (trackballElements.length > 0) {
            elements = [];

            for (var i_1 = 0; i_1 < trackballElements.length; i_1++) {
              if (trackballElements[i_1].id.indexOf('Trackball') > -1) {
                elements.push(trackballElements[i_1]);
              }
            }

            this.removeStyles(elements, chart);
          }
        }
      }
    },
    blurEffect: function blurEffect(chartId, charts, legendClick) {
      if (legendClick === void 0) {
        legendClick = false;
      }

      var visibility = this.checkVisibility(charts.highlightDataIndexes, charts) || this.checkVisibility(charts.selectedDataIndexes, charts);
      var seriesCollection = document.getElementById(charts.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");

      for (var i = 0; i < seriesCollection.length; i++) {
        var index = parseInt(seriesCollection[i].id.split('SeriesGroup')[1]);
        this.checkSelectionElements(this.findDOMElement(charts.element.id + 'SeriesGroup' + index), this.generateStyle(charts.element.id + 'SeriesGroup' + index, charts), visibility, legendClick, index, charts);

        if (!sf.base.isNullOrUndefined(this.findDOMElement(charts.element.id + 'SymbolGroup' + index))) {
          this.checkSelectionElements(this.findDOMElement(charts.element.id + 'SymbolGroup' + index), this.generateStyle(charts.element.id + 'SymbolGroup' + index, charts), visibility, legendClick, index, charts);
        }
      }
    },
    checkVisibility: function checkVisibility(selectedIndexes, chart) {
      if (!selectedIndexes) {
        return false;
      }

      var visible = false;
      var uniqueSeries = [];

      for (var _i = 0, selectedIndexes_1 = selectedIndexes; _i < selectedIndexes_1.length; _i++) {
        var index = selectedIndexes_1[_i];

        if (uniqueSeries.indexOf(index.series) === -1) {
          uniqueSeries.push(index.series);
        }
      }

      for (var _a = 0, uniqueSeries_1 = uniqueSeries; _a < uniqueSeries_1.length; _a++) {
        var index = uniqueSeries_1[_a];

        if (document.getElementById(chart.element.id + 'SeriesGroup' + index)) {
          visible = true;
          break;
        }
      }

      return visible;
    },
    findElements: function findElements(chart, series, index, suffix, marker) {
      if (suffix === void 0) {
        suffix = '';
      }

      if (chart.isSeriesMode) {
        return this.getSeriesElements(index.series.toString(), chart);
      } else if (chart.currentMode === 'Cluster') {
        return this.getClusterElements(chart, index);
      } else {
        return this.findDOMElementByIndex(chart, index, suffix, marker);
      }
    },
    removeMultiSelectElements: function removeMultiSelectElements(chart, index, currentIndex) {
      var series;
      var marker = this.getSeriesElements(currentIndex.series.toString(), chart);

      for (var i = 0; i < index.length; i++) {
        series = chart.seriesTypes[index[i].series];

        if (chart.isSeriesMode && !this.toEquals(index[i], currentIndex, chart.isSeriesMode, chart) || chart.currentMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false, chart) || !chart.isSeriesMode && this.toEquals(index[i], currentIndex, true, chart) && !this.toEquals(index[i], currentIndex, false, chart)) {
          this.removeStyles(this.findElements(chart, series, index[i], '', false), chart);

          if (chart.element.id + "SymbolGroup" + index[i].series) {
            this.removeStyles(this.findElements(chart, series, index[i], '', true), chart);
          }

          index.splice(i, 1);
          i--;
        }
      }
    },
    checkSelectionElements: function checkSelectionElements(element, className, visibility, legendClick, series, chart) {
      var children = [];

      if (element.id.indexOf('Series') > -1) {
        if (this.pointIdRequired(chart.seriesTypes[series])) {
          children = chart.isSeriesMode ? [element] : element.querySelectorAll("[id*='_Series']");

          if (chart.seriesTypes[series] === 'Histogram') {
            children.push(this.findDOMElement(chart.element.id + '_Series_' + series + '_NDLine'));
          }

          if (chart.seriesTypes[series] === 'Waterfall') {
            children.push(this.findDOMElement(chart.element.id + '_Series_' + series + '_Connector'));
          }

          if (chart.seriesTypes[series] === 'BoxAndWhisker') {
            children = this.findDOMElement(chart.element.id + 'SymbolGroup' + series).querySelectorAll("path,ellipse");
          }
        } else {
          children = chart.isSeriesMode ? [element] : element.querySelectorAll("[id*='_Series']");
        }
      }

      if (chart.selectionMode !== 'None' || chart.highlightMode !== 'None') {
        children = element.querySelectorAll("[id*='_Series']");
      }

      var elementClassName;
      var parentClassName;
      var legendShape;
      var selectElement = element;
      var parentElement = !this.isRectSeries(chart.seriesTypes[series]) ? this.findDOMElement(chart.element.id + "_Series_" + series) : null;

      for (var i = 0; i < children.length; i++) {
        elementClassName = children[i].getAttribute('class');
        parentClassName = !sf.base.isNullOrUndefined(parentElement) ? parentElement.getAttribute('class') : '';

        if (chart.selectionMode !== 'None' || chart.highlightMode !== 'None') {
          className = elementClassName.indexOf('selection') > 0 || elementClassName.indexOf('highlight') > 0 ? elementClassName : className;
          className = parentClassName.indexOf('selection') > 0 || parentClassName.indexOf('highlight') > 0 ? parentClassName : className;
        }

        if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(children[i], chart.unSelected);
        } else {
          selectElement = children[i];
          this.removeSvgClass(children[i], chart.unSelected);
          this.removeSvgClass(parentElement, chart.unSelected);
        }

        if (children[i].id.indexOf('Trackball') > 0 && selectElement.classList[0] === className) {
          this.removeSvgClass(children[i], chart.unSelected);
          this.removeSvgClass(parentElement, chart.unSelected);
          this.addSvgClass(children[i], className);
        }
      }

      if (element.id.indexOf('Symbol') > -1) {
        if (element.querySelectorAll('.' + className)[0] && element.querySelectorAll('.' + className)[0].getAttribute('class') === className) {
          var symbolEle = this.findDOMElement(element.id + '_Series_' + element.id[element.id.length - 1]);
          var seriesClassName = symbolEle && symbolEle.hasAttribute('class') ? symbolEle.getAttribute('class') : '';

          if (seriesClassName.indexOf(chart.unSelected) > -1) {
            this.removeSvgClass(symbolEle, chart.unSelected);
          }
        }
      }

      legendShape = this.findDOMElement(chart.id + '_chart_legend_shape_' + series);

      if (legendShape) {
        if (legendShape.hasAttribute('class')) {
          this.removeSvgClass(legendShape, legendShape.getAttribute('class'));

          if (!sf.base.isNullOrUndefined(chart.highlightColor && chart.highlightColor !== '')) {
            legendShape.setAttribute('stroke', "");

            if (chart.highlightPattern === 'None') {
              legendShape.setAttribute('fill', "");
            }
          }
        }

        elementClassName = selectElement.getAttribute('class') || '';
        parentClassName = selectElement.parentNode.getAttribute('class') || '';

        if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(legendShape, chart.unSelected);
          this.removeSvgClass(legendShape, className);

          if (chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
            legendShape.setAttribute('stroke', "");

            if (chart.highlightPattern === 'None') {
              legendShape.setAttribute('fill', "");
            }
          }
        } else {
          this.removeSvgClass(legendShape, chart.unSelected);

          if (!sf.base.isNullOrUndefined(chart.highlightColor) && chart.highlightColor !== '') {
            legendShape.setAttribute('stroke', "");

            if (chart.highlightPattern === 'None') {
              legendShape.setAttribute('fill', "");
            }
          }

          if (elementClassName === '' && parentClassName === '' || elementClassName.trim() === 'EJ2-Trackball') {
            this.removeSvgClass(legendShape, className);
          } else {
            this.addSvgClass(legendShape, className);

            if (className.indexOf('highlight') > 0 && chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
              legendShape.setAttribute('stroke', chart.highlightColor);

              if (chart.styleId.indexOf('highlight') > 0 && chart.highlightPattern === 'None') {
                legendShape.setAttribute('fill', chart.highlightColor);
              }
            }
          }
        }

        if (legendClick && parentClassName.indexOf(className) > -1) {
          this.addSvgClass(legendShape, className);
        }
      }
    },
    addSvgClass: function addSvgClass(element, className) {
      var elementClassName = element.getAttribute('class') || '';
      elementClassName += elementClassName !== '' ? ' ' : '';

      if (elementClassName.indexOf(className) === -1) {
        element.setAttribute('class', elementClassName + className);
      }
    },
    isRectSeries: function isRectSeries(seriesType) {
      if (seriesType === 'Column' || seriesType === 'StackingColumn' || seriesType === 'Bar' || seriesType === 'StackingBar' || seriesType === 'RangeColumn' || seriesType === 'Histogram' || seriesType === 'BoxAndWhisker') {
        return true;
      } else {
        return false;
      }
    },
    pointIdRequired: function pointIdRequired(seriesType) {
      if (this.isRectSeries(seriesType) || seriesType === 'Bubble' || seriesType === 'Scatter') {
        return true;
      } else {
        return false;
      }
    },
    getSeriesElements: function getSeriesElements(index, chart) {
      var seriesElements;
      var seriesElementsArray = [];
      var isMarker = !sf.base.isNullOrUndefined(document.getElementById(chart.element.id + 'SymbolGroup' + index)) && chart.seriesTypes[index] !== 'Scatter' && chart.seriesTypes[index] !== 'Bubble' && !this.isRectSeries(chart.seriesTypes[index]);

      if (isMarker) {
        seriesElements = this.findDOMElement(chart.element.id + 'SymbolGroup' + index).querySelectorAll('#' + chart.element.id + 'SymbolGroup' + index + ' path');
        seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);

        if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SymbolGroup' + index).querySelectorAll('#' + chart.element.id + 'SymbolGroup' + index + ' ellipse'))) {
          seriesElements = this.findDOMElement(chart.element.id + 'SymbolGroup' + index).querySelectorAll('#' + chart.element.id + 'SymbolGroup' + index + ' ellipse');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      } else {
        seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
        seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);

        if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' ellipse'))) {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' ellipse');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      }

      if (chart.seriesTypes[index].indexOf('Area') > -1 || chart.seriesTypes[index].toLowerCase().indexOf('line') > -1) {
        if (isMarker) {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
          seriesElementsArray.push.apply(seriesElementsArray, this.addSeriesElements(seriesElementsArray, seriesElements));
        } else {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      }

      if (chart.seriesTypes[index] === 'Histogram') {
        var seriesElement = this.findDOMElement(chart.element.id + '_Series_' + index + '_NDLine');
        seriesElementsArray.push(seriesElement);
      }

      return seriesElementsArray;
    },
    addSeriesElements: function addSeriesElements(seriesElements, markerElements) {
      for (var i = 0; i < markerElements.length; i++) {
        var element = document.getElementById(markerElements[i].id);

        if (element != null) {
          seriesElements.push(element);
        }

        seriesElements = seriesElements.filter(function (elem, index, self) {
          return index === self.indexOf(elem);
        });
      }

      return seriesElements;
    },
    findDOMElementByIndex: function findDOMElementByIndex(chart, index, suffix, marker) {
      if (suffix === void 0) {
        suffix = '';
      }

      var elementId = chart.element.id + '_Series_' + index.series + '_Point' + '_' + index.point;
      var series = chart.seriesTypes[index.series];
      elementId = !this.isRectSeries(series) && series !== 'Scatter' && series !== 'Bubble' && marker ? elementId + '_Symbol' + suffix : elementId;

      if (series === 'BoxAndWhisker') {
        elementId = elementId + "_BoxPath";
      }

      return [this.findDOMElement(elementId), (series === 'RangeArea' || series === 'SplineRangeArea') && marker ? this.findDOMElement(elementId + '1') : null];
    },
    applyStyles: function applyStyles(elements, chart) {
      for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
        var element = elements_2[_i];

        if (element) {
          this.removeSvgClass(element, chart.unSelected);
          this.addSvgClass(element, this.getSelectionClass(element.id, chart));

          if (chart.styleId.indexOf('highlight') > 0 && chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor) && chart.highlightPattern === 'None') {
            if (element.id.indexOf('Group') > 0) {
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].setAttribute('fill', chart.highlightColor);
              }
            } else {
              element.setAttribute('fill', chart.highlightColor);
            }
          }
        }
      }
    },
    getClusterElements: function getClusterElements(chart, index) {
      var clusters = [];
      var seriesStyle;
      var selectedElements;
      var seriesCollection = document.getElementById(chart.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");
      var seriesMarkerCollection = document.getElementById(chart.element.id + "SeriesCollection").querySelectorAll("[id*='SymbolGroup']");
      var seriesElements;
      var seriesElementsArray;

      for (var seriesG = 0; seriesG < seriesCollection.length; seriesG++) {
        seriesElements = seriesCollection[seriesG].querySelectorAll('#' + seriesCollection[seriesG].id + ' path');
        seriesElementsArray = Array.prototype.slice.call(seriesElements);

        for (var series = 0; series < seriesElementsArray.length; series++) {
          var seriesData = seriesElementsArray[series].getAttribute('data-point').split(',');
          index = new Index(+seriesData[4], index.point);

          if (this.isRectSeries(seriesData[3])) {
            clusters.push(this.findDOMElementByIndex(chart, index)[0]);
          }

          clusters.push(this.findDOMElementByIndex(chart, index, '', seriesData[9] === 'True')[0]);
          seriesStyle = this.generateStyle(seriesElementsArray[series].id, chart);
          selectedElements = document.querySelectorAll('.' + seriesStyle);
          this.findTrackballElements(selectedElements, seriesStyle);
          var clusterIndex = seriesData[9] === 'True' && this.isRectSeries(seriesData[3]) ? 2 : 1;

          if (!chart.allowMultiSelection && selectedElements.length > 0 && selectedElements[0].id !== clusters[clusters.length - clusterIndex].id) {
            this.removeSelection(chart, index.series, selectedElements, seriesStyle, true);
          }
        }
      }

      return clusters;
    },
    clusterSelection: function clusterSelection(chart, index) {
      this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
    },
    removeSelection: function removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {
      var elementId;
      var seriesElements = document.getElementById(chart.element.id + 'SeriesGroup' + series).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + series + ' path');
      var seriesElementsArray = Array.prototype.slice.call(seriesElements);

      if (selectedElements.length > 0) {
        var elements = [];

        for (var i = 0; i < selectedElements.length; i++) {
          elements.push(selectedElements[i]);
        }

        this.removeStyles(elements, chart);
        chart.isSeriesMode = true;
        this.addOrRemoveIndex(chart.selectedDataIndexes, new Index(series, NaN), chart);

        for (var value = 0; value < selectedElements.length; value++) {
          elementId = selectedElements[value].id;
          seriesStyle = this.generateStyle(elementId, chart);

          if (document.querySelectorAll('.' + seriesStyle).length > 0) {
            for (var _i = 0, elements_3 = elements; _i < elements_3.length; _i++) {
              var element = elements_3[_i];
              this.checkSelectionElements(element, seriesStyle, true, true, series, chart);
            }

            isBlurEffectNeeded = false;
            break;
          }
        }

        if (isBlurEffectNeeded) {
          chart.isSeriesMode = chart.selectionMode === 'Series';
          this.blurEffect(elementId, chart);
        }
      }
    },
    isAlreadySelected: function isAlreadySelected(event, charts) {
      var targetElement = event.target;

      if (event.type === 'click') {
        charts.currentMode = charts.selectionMode;
        charts.styleId = charts.element.id + '_ej2_chart_selection';
      } else if (event.type === 'mousemove' || event.type === 'pointermove') {
        charts.currentMode = charts.highlightMode;
        charts.highlightDataIndexes = [];
        charts.styleId = charts.element.id + '_ej2_chart_highlight';
      }

      if (charts.highlightMode !== 'None' && charts.selectionMode === 'None') {
        if (event.type === 'click') {
          return false;
        }
      }

      if (charts.highlightMode !== 'None' && charts.previousSelectedEle.length !== 0 && charts.previousSelectedEle[0] !== null) {
        charts.previousSelectedEle.filter(function (element) {
          return element !== null;
        });
        var parentNodeId = targetElement.parentNode.id;
        var isElement = void 0;

        if (targetElement.parentNode) {
          isElement = parentNodeId.indexOf('Point') > 0 || parentNodeId.indexOf('Symbol') > 0 ? true : false;
        }

        for (var i = 0; i < charts.previousSelectedEle.length; i++) {
          if (charts.previousSelectedEle[i].hasAttribute('class')) {
            if (charts.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1 && (isElement || event.type === 'click')) {
              charts.previousSelectedEle[i].removeAttribute('class');

              if (charts.highlightColor !== '' && !sf.base.isNullOrUndefined(charts.highlightColor) && charts.highlightPattern === 'None') {
                if (charts.previousSelectedEle[i].id.indexOf('Group') > 0) {
                  for (var j = 0; j < charts.previousSelectedEle[i].children.length; j++) {
                    var child = charts.previousSelectedEle[i].children[j];
                    child.setAttribute('fill', child.getAttribute('data-point').split('.')[2]);
                  }
                } else {
                  charts.previousSelectedEle[i].setAttribute('fill', charts.previousSelectedEle[i].getAttribute('data-point').split('.')[2]);
                }
              }

              this.addOrRemoveIndex(charts.highlightDataIndexes, this.indexFinder(charts.previousSelectedEle[i].id), charts);
            } else if (!isElement && charts.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1) {
              this.performSelection(this.indexFinder(charts.previousSelectedEle[i].id), charts, charts.previousSelectedEle[i]);
            }
          }
        }
      }

      return true;
    },
    performSelection: function performSelection(index, chart, element) {
      chart.isSeriesMode = chart.currentMode === "Series";

      if (chart.seriesTypes[index.series] === 'BoxAndWhisker' && element && element.id === chart.element.id + '_Series_' + index.series + '_Point_' + index.point + '_BoxPath') {
        element = element.parentNode;
      }

      if (chart.seriesTypes[index.series] === 'Area' && (chart.currentMode === 'Point' || chart.currentMode === 'Cluster') && element && element.id === chart.element.id + '_Series_' + index.series) {
        var className = this.generateStyle(element.id, chart);
        var selectionEle = document.querySelectorAll('.' + className);

        if (!sf.base.isNullOrUndefined(selectionEle)) {
          this.findTrackballElements(selectionEle, className);
          this.blurEffect(element.id, chart, element.getAttribute('data-point').split(',')[8] === 'True');
        }
      }

      switch (chart.currentMode) {
        case 'Series':
          this.selection(chart, index, this.getSeriesElements(index.series.toString(), chart));
          this.selectionComplete(chart, index, chart.selectionMode);
          this.blurEffect(element.id, chart);
          break;

        case 'Point':
          if (!isNaN(index.point) && element) {
            var pointElements = [];
            pointElements.push(element);
            this.selection(chart, index, pointElements);
            this.selectionComplete(chart, index, chart.selectionMode);
            this.blurEffect(element.id, chart);
          }

          break;

        case 'Cluster':
          if (!isNaN(index.point)) {
            this.clusterSelection(chart, index);
            this.selectionComplete(chart, index, chart.selectionMode);
            this.blurEffect(element.id, chart);
          }

          break;
      }
    },
    selection: function selection(chart, index, selectedElements) {
      selectedElements = selectedElements.filter(function (element) {
        return element !== null;
      });

      if (!(chart.currentMode === 'Lasso')) {
        if (!chart.allowMultiSelection && chart.currentMode.indexOf('Drag') === -1 && chart.styleId.indexOf('highlight') === -1 && chart.selectionMode !== 'None') {
          this.removeMultiSelectElements(chart, chart.selectedDataIndexes, index, selectedElements);
        }
      }

      if (!sf.base.isNullOrUndefined(selectedElements[0])) {
        if (this.isRectSeries(chart.seriesTypes[index.series]) && chart.seriesTypes[index.series] !== 'Histogram') {
          if (selectedElements[0].id) {
            if (document.getElementById(selectedElements[0].id + '_Symbol')) {
              selectedElements.push(this.findDOMElement(selectedElements[0].id + '_Symbol'));
            } else if (selectedElements[0].id.indexOf('SeriesGroup') !== -1) {
              if (document.getElementById(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup'))) {
                selectedElements.push(this.findDOMElement(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup')));
              }
            }
          }
        }

        var isAdd = void 0;
        var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');
        var pClassName = selectedElements[0].parentNode && (selectedElements[0].parentNode.getAttribute('class') || '');

        if (className !== '' && chart.currentMode !== 'Cluster') {
          this.findTrackballElements(selectedElements, className);
        }

        if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id, chart)) > -1) {
          this.removeStyles(selectedElements, chart);
        } else if (selectedElements[0].parentNode && pClassName.indexOf(this.getSelectionClass(selectedElements[0].id, chart)) > -1) {
          this.removeStyles([selectedElements[0].parentNode], chart);
        } else {
          chart.previousSelectedEle = chart.highlightMode !== 'None' ? selectedElements : [];
          this.applyStyles(selectedElements, chart);
          isAdd = true;
        }

        if (chart.styleId.indexOf('highlight') > 0 && chart.highlightMode !== 'None') {
          this.addOrRemoveIndex(chart.highlightDataIndexes, index, chart, isAdd);
        } else {
          this.addOrRemoveIndex(chart.selectedDataIndexes, index, chart, isAdd);
        }
      }
    },
    legendSelection: function legendSelection(e, element) {
      var targetId = e.target['id'];
      var charts = element.blazor__instance;
      var values = [this.id + "_chart_legend_text_", this.id + "_chart_legend_shape_marker_", this.id + "_chart_legend_shape_", this.id + "_chart_legend_g_"];
      var currentMode = 'None';
      var selectedElements;
      var currentIndex;
      var targetElement;

      for (var i = 0; i < values.length; i++) {
        if (!targetId.indexOf(values[i])) {
          currentIndex = parseInt(targetId.split(values[i])[1]);
          break;
        }
      }

      if (targetId.indexOf("text") <= 0) {
        targetElement = Chart.findDOMElement(targetId);
      } else {
        targetElement = null;
      }

      if (e.type === "mousemove") {
        if (targetId.indexOf('text')) {
          targetElement = Chart.findDOMElement(targetId.replace('text', 'shape'));
        }

        if (targetElement.hasAttribute('class')) {
          if (charts.styleId.indexOf('highlight') > 0 && charts.highlightMode !== 'None' && charts.styleId.indexOf('selection') > 1 && charts.selectionMode !== 'None') {
            return;
          }
        }

        currentMode = charts.highlightMode;

        if (currentMode == 'None' && this.element.enableHighlight) {
          currentMode = 'Series';
        }
      }

      var isPreSelected = this.isAlreadySelected(e, charts);

      if (isPreSelected) {
        this.seriesStyle = this.generateStyle(charts.element.id + 'SeriesGroup' + currentIndex, charts);
        selectedElements = document.querySelectorAll('.' + this.seriesStyle);
        this.isSeriesMode = currentMode == 'Series';
        this.isBlurEffectNeeded = true;

        if (selectedElements.length > 0) {
          this.removeSelection(charts, currentIndex, selectedElements, this.seriesStyle, this.isBlurEffectNeeded);
        } else {
          var seriesCollection = document.getElementById(charts.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");

          for (var seriesG = 0; seriesG < seriesCollection.length; seriesG++) {
            if (!this.isMultiSelect && seriesG != currentIndex) {
              this.seriesStyle = this.generateStyle(seriesCollection[seriesG].id, charts);
              selectedElements = document.querySelectorAll('.' + this.seriesStyle);
              this.removeSelection(charts, currentIndex, selectedElements, this.seriesStyle, this.isBlurEffectNeeded);
            }
          }

          var seriesElements = this.getSeriesElements(currentIndex.toString(), charts);
          charts.isSeriesMode = true;

          for (var i = 0; i < seriesElements.length; i++) {
            this.checkSelectionElements(seriesElements[i], this.seriesStyle, false, true, currentIndex, charts);
          }

          this.isSeriesMode = true;
          var indexAndPoint = new Index(currentIndex, 0);
          this.selection(charts, indexAndPoint, seriesElements);
          this.isSeriesMode = this.selectionMode == 'Series';
          this.blurEffect(charts.element.id, charts, true);
        }
      }
    },
    selectionComplete: function selectionComplete(chart, index, selectionMode) {
      var pointX;
      var pointY;
      var regionY;
      var pointIndex;
      var seriesIndex;
      var selectedPointValues = [];
      var yValue;
      var selectedPointX;
      var seriesType;
      var SeriesCategory;
      var seriesArray = this.getSeriesElements(index.series.toString(), chart);

      if (selectionMode === 'Cluster') {
        for (var i = 0; i < seriesArray.length; i++) {
          seriesType = this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[3];
          SeriesCategory = this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[11];
          regionY = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[10];

          if (this.findDOMElement(seriesArray[i].id).getAttribute('visibility') === 'visible') {
            for (var j = 0; j < chart.selectedDataIndexes.length; j++) {
              pointIndex = chart.allowMultiSelection ? chart.selectedDataIndexes[j].point : index.point;
              seriesIndex = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[4];
              pointX = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[0];
              pointY = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[1];

              if (!isNaN(pointIndex)) {
                yValue = seriesType !== 'RangeArea' || 'SplineRangeArea' ? pointY : regionY;
                selectedPointX = pointX;
              }

              if (chart.primaryXAxis === 'Category') {
                selectedPointX = pointX.toLocaleString();
              } else if (chart.primaryXAxis === 'DateTime') {
                selectedPointX = new Date(pointX);
              }

              if (SeriesCategory !== 'Indicator') {
                selectedPointValues.push({
                  x: selectedPointX,
                  y: yValue,
                  seriesIndex: seriesIndex,
                  pointIndex: pointIndex
                });
              }

              if (seriesType === 'RangeArea' || seriesType === 'SplineRangeArea') {
                selectedPointValues.push({
                  x: selectedPointX,
                  y: regionY,
                  seriesIndex: seriesIndex,
                  pointIndex: pointIndex
                });
              }
            }
          }
        }
      } else if (selectionMode === 'Series') {
        if (chart.allowMultiSelection) {
          for (var i = 0; i < chart.selectedDataIndexes.length; i++) {
            seriesIndex = chart.selectedDataIndexes[i].series;
            selectedPointValues.push({
              seriesIndex: seriesIndex
            });
          }
        } else {
          seriesIndex = chart.selectedDataIndexes.length > 0 ? chart.selectedDataIndexes[0].series : 0;
          selectedPointValues.push({
            seriesIndex: seriesIndex
          });
        }
      } else if (selectionMode === 'Point') {
        for (var i = 0; i < chart.selectedDataIndexes.length; i++) {
          pointIndex = chart.selectedDataIndexes[i].point;
          seriesIndex = chart.selectedDataIndexes[i].series;
          pointX = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[0];
          pointY = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[1];
          regionY = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[10];

          if (!isNaN(pointIndex)) {
            selectedPointX = pointX;
            yValue = seriesType !== 'RangeArea' || 'SplineRangeArea' ? pointY : regionY;

            if (chart.primaryXAxis === 'Category') {
              selectedPointX = pointX.toLocaleString();
            } else if (chart.primaryXAxis === 'DateTime') {
              selectedPointX = new Date(pointX);
            }

            selectedPointValues.push({
              x: selectedPointX,
              y: yValue,
              seriesIndex: seriesIndex,
              pointIndex: pointIndex
            });
          }
        }
      }

      chart.dotnetref.invokeMethodAsync("OnSelectioChange", selectedPointValues);
    }
  };
  return Chart;
}();

/***/ })

}]);(async()=>{await import("/_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js").then(()=>{sfBlazor.loadDependencies('sfchart');})})();