(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-gantt"],{

/***/ "./bundles/sf-gantt.js":
/*!*****************************!*\
  !*** ./bundles/sf-gantt.js ***!
  \*****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_gantt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-gantt.js */ "./modules/sf-gantt.js");
/* harmony import */ var _modules_sf_gantt_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_gantt_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-gantt.js":
/*!*****************************!*\
  !*** ./modules/sf-gantt.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Gantt = function () {
  'use strict';
  /**
   * Specifies SfGantt class for native blazor rendering.
   * @hidden
   */

  var SfGantt =
  /** @class */
  function () {
    function SfGantt(dataId, element, options, dotnetRef) {
      this.toolbarHeight = 0;
      this.chartPreviousScroll = {
        top: 0,
        left: 0
      };
      this.treegridPreviousScroll = {
        top: 0,
        left: 0
      };
      this.spinnerShown = false;
      this.isTaskbarEditingEventMapped = false;
      this.scrollbarUpdate = false;
      window.sfBlazor = window.sfBlazor;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.isFromTreeGrid = false;
      this.options = options;
      this.dataId = dataId;
      window.sfBlazor.setCompInstance(this);
    }

    SfGantt.prototype.getOffsetRect = function (element) {
      var box = element.getBoundingClientRect();
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
      var clientTop = document.documentElement.clientTop || document.body.clientTop || 0;
      var clientLeft = document.documentElement.clientLeft || document.body.clientLeft || 0;
      var top = box.top + scrollTop - clientTop;
      var left = box.left + scrollLeft - clientLeft;
      return {
        top: Math.round(top),
        left: Math.round(left),
        width: box.width,
        height: box.height
      };
    };

    SfGantt.prototype.getParentElement = function (elem, selector, isID) {
      var parent = elem;

      while (parent) {
        if (isID ? parent.id === selector : parent.classList.contains(selector)) {
          break;
        }

        parent = parent.parentElement;
      }

      return parent;
    };

    return SfGantt;
  }();
  /**
   * CSS Constants
   */

  /** @hidden */
  // Timeline-Class


  var timelineSingleHeaderOuterDiv = 'e-timeline-single-header-outer-div';
  var holidayLabel = 'e-span';
  var taskBarMainContainer = 'e-taskbar-main-container';
  var taskBarLeftResizer = 'e-taskbar-left-resizer';
  var taskBarRightResizer = 'e-taskbar-right-resizer';
  var childProgressResizer = 'e-child-progress-resizer';
  var leftResizeGripper = 'e-left-resize-gripper';
  var rightResizeGripper = 'e-right-resize-gripper';
  var progressResizeGripper = 'e-progress-resize-gripper';
  var chartBodyContainer = 'e-chart-root-container';
  var chartRow = 'e-chart-row';
  var leftLabelContainer = 'e-left-label-container';
  var rightLabelContainer = 'e-right-label-container';
  var traceChildProgressBar = 'e-gantt-child-progressbar';
  var traceChildTaskBar = 'e-gantt-child-taskbar';
  var traceParentTaskBar = 'e-gantt-parent-taskbar';
  var traceParentProgressBar = 'e-gantt-parent-progressbar';
  var parentMilestone = 'e-gantt-parent-milestone';
  var traceMilestone = 'e-gantt-milestone';
  var Active = 'e-active-container';
  var LeftLabel = 'e-left-label-inner-div';
  var RightLabel = 'e-right-label-inner-div';
  var connectorPointLeft = 'e-connectorpoint-left';
  var connectorPointRight = 'e-connectorpoint-right';
  var connectorPointLeftHover = 'e-connectorpoint-left-hover';
  var connectorPointRightHover = 'e-connectorpoint-right-hover';
  var falseLine = 'e-gantt-false-line';
  var rightConnectorPointOuterDiv = 'e-right-connectorpoint-outer-div';
  var connectorLineContainer = 'e-connector-line-container';
  var connectorLineZIndex = 'e-connector-line-z-index';
  var connectorPointAllowBlock = 'e-connectorpoint-allow-block';
  /**
   * Splitter module is used to define the splitter position in Gantt layout.
   */

  var ChartScroll =
  /** @class */
  function () {
    function ChartScroll(ganttParent, element, ganttHeight, contentHeight) {
      this.parent = ganttParent;
      this.chartElement = element.querySelector('.e-gantt-chart-pane');
      this.element = element.querySelector('.e-chart-scroll-container');
      this.timelineHeaderElement = element.querySelector('.e-timeline-header-container');
      this.holidaySpanElement = element.querySelectorAll('.' + holidayLabel);
      this.addEventListeners();
      this.ChartHeight(element);

      if (!sf.base.isNullOrUndefined(this.holidaySpanElement)) {
        this.UpdateHolidayLabel(contentHeight);
      }
    }

    ChartScroll.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.element, 'scroll', this.onScroll, this);
      sf.base.EventHandler.add(this.chartElement, 'mousedown', this.mouseDownHandler, this);
    };

    ChartScroll.prototype.removeEventListeners = function () {
      sf.base.EventHandler.remove(this.element, 'scroll', this.onScroll);
      sf.base.EventHandler.remove(this.chartElement, 'mousedown', this.mouseDownHandler);
    };

    ChartScroll.prototype.gridScrollHandler = function (top) {
      this.element.scrollTop = top;
      this.parent.isFromTreeGrid = true;
    };

    ChartScroll.prototype.showHideSpinner = function (isShow) {
      var parent = this.parent;

      if (isShow && !this.parent.spinnerShown) {
        this.parent.dotNetRef.invokeMethodAsync('ShowSpinner');
        this.parent.spinnerShown = true;
      } else if (!isShow && this.parent.spinnerShown) {
        parent.dotNetRef.invokeMethodAsync("HideSpinner");
        parent.spinnerShown = false;
      }
    };

    ChartScroll.prototype.onScroll = function () {
      var parent = this.parent;
      var chartScroll = this;
      parent.scrollbarUpdate = true;

      if (this.element.scrollTop !== parent.chartPreviousScroll.top && this.parent.options.enableVirtualization) {
        this.showHideSpinner(true);
        window.clearTimeout(this.isScrolling);
        this.isScrolling = setTimeout(function () {
          chartScroll.showHideSpinner(false);
        }, 200);
      }

      if (this.element.scrollLeft !== this.parent.chartPreviousScroll.left) {
        this.timelineHeaderElement.scrollLeft = this.element.scrollLeft;
        this.parent.chartPreviousScroll.left = this.element.scrollLeft;
      }

      if (this.element.scrollTop !== this.parent.chartPreviousScroll.top) {
        if (!this.parent.isFromTreeGrid) {
          this.parent.treeGridModule.updateScrollTop(this.element.scrollTop);
        }

        this.parent.chartPreviousScroll.top = this.element.scrollTop;
        this.parent.isFromTreeGrid = false;
      }
    };

    ChartScroll.prototype.mouseDownHandler = function (e) {
      var ChartElement = this.parent.getParentElement(e.target, 'e-gantt-chart');

      if (ChartElement != null) {
        var target = null;
        var cellUid = null;

        if (this.parent.getParentElement(e.target, 'e-timeline-header-container')) {
          target = "Header";
        } else if (this.parent.getParentElement(e.target, 'e-content')) {
          target = "Content";
          cellUid = this.parent.getParentElement(e.target, 'e-chart-row-cell') ? this.parent.getParentElement(e.target, 'e-chart-row-cell').getAttribute('data-uid') : null;
        }

        if (target == "Header" || target == "Content") {
          this.parent.dotNetRef.invokeMethodAsync("ChartMouseDownHandler", target, cellUid);
        }
      }
    };

    ChartScroll.prototype.setScrollLeft = function (scrollLeft) {
      this.element.scrollLeft = scrollLeft;
      this.timelineHeaderElement.scrollLeft = this.element.scrollLeft;
      this.parent.chartPreviousScroll.left = this.element.scrollLeft;
    };

    ChartScroll.prototype.setScrollTop = function (scrollTop) {
      this.element.scrollTop = scrollTop;
      this.parent.treeGrid.element.querySelector('.e-content').scrollTop = scrollTop;
    };

    ChartScroll.prototype.ChartHeight = function (element) {
      this.toolbarElement = element.querySelector('#' + element.id + '_Gantt_Toolbar');
      this.viewPortHeight = this.parent.height - this.parent.toolbarHeight - this.timelineHeaderElement.offsetHeight;
      this.element.style.height = 'calc(100% - ' + this.timelineHeaderElement.offsetHeight + 'px)';
    };

    ChartScroll.prototype.UpdateHolidayLabel = function (contentHeight) {
      var length = this.holidaySpanElement.length;

      for (var label = 0; label < length; label++) {
        this.holidaySpanElement[label].style.top = sf.base.formatUnit(this.viewPortHeight < contentHeight ? contentHeight / 2 : this.viewPortHeight / 2);
      }
    };

    ChartScroll.prototype.destroy = function () {
      this.removeEventListeners();
    };

    return ChartScroll;
  }();

  var TreeGrid =
  /** @class */
  function () {
    /**
    * Constructor for the Grid scrolling.
    * @hidden
    */
    function TreeGrid(ganttParent, content) {
      this.parent = ganttParent;
      this.content = content;
      this.addEventListeners();
    }

    TreeGrid.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.content, 'scroll', this.scrollHandler, this);
      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */

      sf.base.EventHandler.add(window, 'resize', this.windowResize, this);
    };

    TreeGrid.prototype.removeEventListeners = function () {
      sf.base.EventHandler.remove(this.content, 'scroll', this.scrollHandler);
      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */

      sf.base.EventHandler.remove(window, 'resize', this.windowResize);
    };

    TreeGrid.prototype.scrollHandler = function (e) {
      if (this.content.scrollTop !== this.parent.treegridPreviousScroll.top) {
        this.parent.chartScrollModule.gridScrollHandler(this.content.scrollTop);
      }

      this.parent.treegridPreviousScroll.top = this.content.scrollTop;
    };
    /**
     * Method trigger while user perform window resize.
     *
     * @returns {void} .
     * @private
     */


    TreeGrid.prototype.windowResize = function () {
      if (sf.base.Browser.isDevice) {
        this.parent.dotNetRef.invokeMethodAsync('WindowResize');
      }
    };

    TreeGrid.prototype.updateScrollTop = function (top) {
      this.content.scrollTop = top;
      this.parent.treegridPreviousScroll.top = this.content.scrollTop;
    };

    TreeGrid.prototype.destroy = function () {
      this.removeEventListeners();
    };

    return TreeGrid;
  }();

  var __assign = undefined && undefined.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return __assign.apply(this, arguments);
  };

  var TaskbarEdit =
  /** @class */
  function () {
    /**
    * Constructor for the taskbar editing
    * @hidden
    */
    function TaskbarEdit(ganttParent) {
      this.elementOffsetLeft = 0;
      this.elementOffsetTop = 0;
      this.elementOffsetWidth = 0;
      this.elementOffsetHeight = 0;
      this.restrictTaskbarEdit = false;
      this.parent = ganttParent;
      this.initPublicProp();
      this.ganttChartTableBody = this.parent.element.querySelector("#" + this.parent.element.id + "_chartContentBody");
      this.chartPane = this.parent.element.querySelector(".e-gantt-chart-pane");
      this.chartBodyContainer = this.parent.element.querySelector("." + chartBodyContainer);
      this.addEventListeners();
    }

    TaskbarEdit.prototype.initPublicProp = function () {
      this.taskBarEditElement = null;
      this.taskBarEditRecord = null;
      this.taskBarEditAction = null;
      this.dragMouseLeave = false;
      this.isMouseDragging = false;
      this.isTaskbarHold = false;
      this.connectorPointWidth = null;
      this.connectorSecondAction = null;
      this.toPredecessorText = null;
      this.highlightedSecondElement = null;
      this.falseLine = null;
    };

    TaskbarEdit.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseDown, this);
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove, this);
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchCancelEvent, this.ganttMouseLeave, this);
      sf.base.EventHandler.add(document, sf.base.Browser.touchEndEvent, this.ganttChartMouseUp, this);
      sf.base.EventHandler.add(this.chartBodyContainer, 'click', this.click, this);
    };

    TaskbarEdit.prototype.removeEventListeners = function () {
      sf.base.EventHandler.remove(this.chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseDown);
      sf.base.EventHandler.remove(this.chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove);
      sf.base.EventHandler.remove(this.chartPane, sf.base.Browser.touchCancelEvent, this.ganttMouseLeave);
      sf.base.EventHandler.remove(document, sf.base.Browser.touchEndEvent, this.ganttChartMouseUp);
      sf.base.EventHandler.remove(this.chartBodyContainer, 'click', this.click);
    };

    TaskbarEdit.prototype.ganttMouseDown = function (e) {
      this.taskbarCanDrag = false;
      var targetElement = this.getElementByPosition(e);
      var tempelement = this.parent.getParentElement(targetElement, taskBarMainContainer);

      if (tempelement == this.taskbarCurrentEditElement) {
        this.taskbarCanDrag = true;
      }

      this.updateTaskBarEditElement(e);
    };

    TaskbarEdit.prototype.click = function (e) {
      var targetElement = this.getElementByPosition(e);
      this.taskbarCurrentEditElement = this.parent.getParentElement(targetElement, taskBarMainContainer);
    };

    TaskbarEdit.prototype.ganttMouseLeave = function (e) {
      this.dragMouseLeave = true;
    };

    TaskbarEdit.prototype.ganttChartMouseUp = function (e) {
      var _this = this;

      this.isTaskbarHold = false;

      if (this.taskBarEditAction && this.isMouseDragging) {
        if (!this.dragMouseLeave) {
          this.parent.dotNetRef.invokeMethodAsync('UpdateResizedData', this.dataGuid, this.taskBarEditAction, this.taskBarEditRecord).then(function (task) {
            if (_this.taskBarEditRecord != null && task != null) {
              _this.taskBarEditRecord.left = task["left"];
              _this.taskBarEditRecord.width = task["width"];
            }

            _this.updateItemPosition();
          });
        } else {
          this.parent.dotNetRef.invokeMethodAsync('UpdateResizedData', null, null, null);
          this.taskBarEditRecord = this.previousItem;
          this.updateItemPosition();
        }
      } else if (this.taskBarEditElement) {
        this.parent.dotNetRef.invokeMethodAsync('UpdateResizedData', null, null, null);

        if (this.falseLine) {
          this.removeFalseLine(true);
        }

        this.initPublicProp();
      } else if (this.tappedPoint) {
        this.taskbarCurrentEditElement = null;
      }

      this.stopScrollTimer();
    };

    TaskbarEdit.prototype.updateItemPosition = function () {
      this.setItemPosition();

      if (this.falseLine) {
        this.removeFalseLine(true);
      }

      this.initPublicProp();
    };

    TaskbarEdit.prototype.updateTaskBarEditElement = function (e) {
      var _this_1 = this;

      var target = this.getElementByPosition(e);
      var element = this.parent.getParentElement(target, taskBarMainContainer);
      this.taskBarEditElement = element;

      if (this.taskBarEditElement && !this.tappedPoint) {
        if (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'click') {
          this.dataGuid = this.taskBarEditElement.getAttribute('rowuniqueid');
          this.parent.dotNetRef.invokeMethodAsync('GetConnectorValues').then(function (width) {
            _this_1.connectorPointWidth = width;
          });
          this.taskBarEditAction = this.getTaskBarAction(e);

          if (this.parent.isTaskbarEditingEventMapped) {
            this.parent.dotNetRef.invokeMethodAsync('OnTaskbarEditing', this.dataGuid, this.taskBarEditAction).then(function (restrict) {
              _this_1.restrictTaskbarEdit = restrict;
            });
          }

          this.parent.dotNetRef.invokeMethodAsync('GetEditedRecord', this.dataGuid, this.taskBarEditAction).then(function (record) {
            _this_1.taskBarEditRecord = record;

            _this_1.updateMouseDownProperties(e);
          });
          this.isTaskbarHold = true;
        }
      } else if (this.taskBarEditElement && this.tappedPoint) {
        var toDataGuid = element.getAttribute('rowuniqueid');
        this.parent.dotNetRef.invokeMethodAsync("RenderConnectorLine", this.tappedPoint, this.dataGuid, toDataGuid);
        this.initPublicProp();
      }

      if ((e.type === 'touchstart' || e.type === 'click') && !sf.base.isNullOrUndefined(this.chartBodyContainer.querySelector('.' + connectorLineContainer))) {
        if (this.taskBarEditElement || this.tappedPoint) {
          sf.base.addClass(this.chartBodyContainer.querySelectorAll('.' + connectorLineContainer), connectorLineZIndex);
        } else {
          sf.base.removeClass(this.chartBodyContainer.querySelectorAll('.' + connectorLineContainer), connectorLineZIndex);
        }
      }
    };

    TaskbarEdit.prototype.updateMouseDownProperties = function (event) {
      var e = this.getCoordinate(event);

      if (e.pageX || e.pageY) {
        var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
        this.mouseDownX = e.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
        this.mouseDownY = e.pageY - containerPosition.top + this.parent.chartPreviousScroll.top;
      }
    };

    TaskbarEdit.prototype.getTaskBarAction = function (e) {
      var mouseDownElement = this.getElementByPosition(e);
      var data = this.taskBarEditRecord;
      var action = '';

      if (mouseDownElement.classList.contains(taskBarLeftResizer)) {
        action = 'LeftResizing';
      } else if (mouseDownElement.classList.contains(taskBarRightResizer)) {
        action = 'RightResizing';
      } else if (mouseDownElement.classList.contains(childProgressResizer) || sf.base.closest(mouseDownElement, '.' + childProgressResizer)) {
        action = 'ProgressResizing';
      } else if (mouseDownElement.classList.contains(connectorPointLeftHover)) {
        action = 'ConnectorPointLeftDrag';
        if (e.type === 'touchstart' || e.type === 'click') this.tappedPoint = 'ConnectorPointLeftDrag';
      } else if (mouseDownElement.classList.contains(connectorPointRightHover)) {
        action = 'ConnectorPointRightDrag';
        if (e.type === 'touchstart' || e.type === 'click') this.tappedPoint = 'ConnectorPointRightDrag';
      } else if (this.parent.options.taskMode === 'Auto' && (sf.base.closest(mouseDownElement, '.' + traceParentTaskBar) || sf.base.closest(mouseDownElement, '.' + parentMilestone))) {
        action = 'ParentDrag';
      } else if (sf.base.closest(mouseDownElement, '.' + traceChildTaskBar)) {
        action = 'ChildDrag';
      } else if (sf.base.closest(mouseDownElement, '.' + traceMilestone)) {
        action = 'MilestoneDrag';
      }

      return action;
    };

    TaskbarEdit.prototype.getElementByPosition = function (event) {
      var e = this.getCoordinate(event);
      e.pageX = e.pageX != null ? e.pageX : 0;
      e.pageY = e.pageY != null ? e.pageY : 0;
      return document.elementFromPoint(e.pageX - window.pageXOffset, e.pageY - window.pageYOffset);
    }; // Get XY coordinates for touch and non-touch device


    TaskbarEdit.prototype.getCoordinate = function (event) {
      var coordinates = {};

      if (event.type === "touchstart" || event.type === "touchmove" || event.type === "touchend" || event.type === "touchleave") {
        var e = event;
        coordinates.pageX = e.changedTouches[0].pageX;
        coordinates.pageY = e.changedTouches[0].pageY;
      } else {
        var e = event;
        coordinates.pageX = e.pageX;
        coordinates.pageY = e.pageY;
      }

      return coordinates;
    };

    TaskbarEdit.prototype.ganttMouseMove = function (event) {
      if (event.type === "touchmove" || event.type === "click") {
        if (!this.taskbarCanDrag) {
          return;
        }
      }

      if (this.taskBarEditAction && this.taskBarEditRecord && this.isTaskbarHold) {
        var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
        var e = this.getCoordinate(event);
        this.mouseMoveX = e.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
        this.mouseMoveY = e.pageY - containerPosition.top + this.parent.chartPreviousScroll.top;
        this.dragMouseLeave = false;
        this.isMouseDragCheck();

        if (this.isMouseDragging) {
          this.taskBarEditingAction(event, false);
        }
      }

      var isTaskbar = sf.base.closest(event.target, '.e-taskbar-main-container');

      if (isTaskbar) {
        if (this.parent.options.allowTaskbarEditing && this.taskBarEditAction !== 'ConnectorPointLeftDrag' && this.taskBarEditAction !== 'ConnectorPointRightDrag') {
          isTaskbar.style.cursor = 'move';
        } else {
          isTaskbar.style.cursor = 'auto';
        }
      }

      if (!sf.base.isNullOrUndefined(this.chartBodyContainer.querySelector('.' + connectorLineContainer))) {
        if (isTaskbar !== null) {
          sf.base.addClass(this.chartBodyContainer.querySelectorAll('.' + connectorLineContainer), connectorLineZIndex);
        } else if (!sf.base.isNullOrUndefined(this.chartBodyContainer.querySelectorAll('.' + connectorLineZIndex))) {
          sf.base.removeClass(this.chartBodyContainer.querySelectorAll('.' + connectorLineContainer), connectorLineZIndex);
        }
      }
    };

    TaskbarEdit.prototype.isMouseDragCheck = function () {
      if (!this.isMouseDragging && this.taskBarEditAction && (this.mouseDownX !== this.mouseMoveX && (this.mouseDownX + 3 < this.mouseMoveX || this.mouseDownX - 3 > this.mouseMoveX) || this.mouseDownY !== this.mouseMoveY && (this.mouseDownY + 3 < this.mouseMoveY || this.mouseDownY - 3 > this.mouseMoveY))) {
        this.isMouseDragging = true;
        var item = this.taskBarEditRecord;
        this.previousItem = __assign({}, item);
        this.taskBarEditElement.setAttribute('aria-grabbed', 'true');
      }
    };

    TaskbarEdit.prototype.updateMouseMoveProperties = function (event) {
      var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
      var e = this.getCoordinate(event);
      var isConnectorLineEdit = this.taskBarEditAction === 'ConnectorPointLeftDrag' || this.taskBarEditAction === 'ConnectorPointRightDrag' ? true : false;

      if (e.pageX || e.pageY) {
        this.mouseMoveX = e.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
        this.mouseMoveY = e.pageY - containerPosition.top + this.parent.chartPreviousScroll.top;
      }

      if (this.taskBarEditRecord.width > 3 && !(this.taskBarEditAction === 'ProgressResizing' && (this.taskBarEditRecord.progress === 0 || this.taskBarEditRecord.progress === 100)) || isConnectorLineEdit) {
        var mouseX = this.mouseMoveX - this.parent.chartPreviousScroll.left + containerPosition.left;
        var mouseY = this.mouseMoveY - this.parent.chartPreviousScroll.top + containerPosition.top;

        if (mouseX + 20 > containerPosition.left + this.chartBodyContainer.offsetWidth) {
          this.timerCount = this.parent.chartPreviousScroll.left;
          this.startScrollTimer('right');
        } else if (mouseX - 10 < containerPosition.left) {
          this.timerCount = this.parent.chartPreviousScroll.left;
          this.startScrollTimer('left');
        } else if (isConnectorLineEdit && mouseY > containerPosition.top + this.chartBodyContainer.offsetHeight - 80) {
          this.timerCount = this.parent.chartPreviousScroll.top;
          this.startScrollTimer('bottom');
        } else if (isConnectorLineEdit && mouseY - 25 < containerPosition.top) {
          this.timerCount = this.parent.chartPreviousScroll.top;
          this.startScrollTimer('top');
        } else if (this.scrollTimer != null) {
          this.stopScrollTimer();
        }
      }

      event.preventDefault();
    };

    TaskbarEdit.prototype.startScrollTimer = function (direction) {
      var _this_1 = this;

      this.stopScrollTimer();
      this.scrollTimer = window.setInterval(function () {
        if (direction === 'right' || direction === 'bottom') {
          _this_1.timerCount = _this_1.timerCount + 1 >= _this_1.parent.totalTimelineWidth ? _this_1.parent.totalTimelineWidth : _this_1.timerCount + 1;
        } else {
          _this_1.timerCount = _this_1.timerCount - 1 < 0 ? 0 : _this_1.timerCount - 1;
        }

        if (direction === 'bottom' || direction === 'top') {
          _this_1.parent.chartScrollModule.setScrollTop(_this_1.timerCount);
        } else {
          _this_1.parent.chartScrollModule.setScrollLeft(_this_1.timerCount);
        }

        if (_this_1.taskBarEditAction === 'ConnectorPointLeftDrag' || _this_1.taskBarEditAction === 'ConnectorPointRightDrag') {
          _this_1.drawFalseLine();
        }
      }, 0);
    };

    TaskbarEdit.prototype.stopScrollTimer = function () {
      window.clearInterval(this.scrollTimer);
      this.scrollTimer = null;
    };

    TaskbarEdit.prototype.taskBarEditingAction = function (e, isMouseClick) {
      // let args: ITaskbarEditedEventArgs = {} as ITaskbarEditedEventArgs;
      if (!this.restrictTaskbarEdit) this.updateMouseMoveProperties(e);

      if (this.taskBarEditAction === 'ProgressResizing' && !this.restrictTaskbarEdit) {
        this.performProgressResize(e);
      } else if (this.taskBarEditAction === 'LeftResizing' && !this.restrictTaskbarEdit) {
        this.enableLeftResizing(e);
      } else if ((this.taskBarEditAction === 'RightResizing' || this.taskBarEditAction === 'ParentResizing') && !this.restrictTaskbarEdit) {
        this.enableRightResizing(e);
      } else if ((this.taskBarEditAction === 'ParentDrag' || this.taskBarEditAction === 'ChildDrag' || this.taskBarEditAction === 'MilestoneDrag') && !this.restrictTaskbarEdit) {
        this.enableDragging(e);
      } else if ((this.taskBarEditAction === 'ConnectorPointLeftDrag' || this.taskBarEditAction === 'ConnectorPointRightDrag') && e.type != 'touchmove' && !this.restrictTaskbarEdit) {
        this.updateConnectorLineSecondProperties(e);
        this.triggerDependencyEvent(e);
        this.drawFalseLine();
      }

      if (!this.restrictTaskbarEdit) this.setItemPosition();

      if (this.taskBarEditAction !== 'ConnectorPointLeftDrag' && this.taskBarEditAction !== 'ConnectorPointRightDrag') {
        this.parent.dotNetRef.invokeMethodAsync('UpdateResizingData', this.dataGuid, this.taskBarEditAction, this.taskBarEditRecord);
      }

      this.updateTooltip(e);
    };
    /**
     * To update tooltip position.
     *
     * @param {number} segmentIndex .
     * @returns {void} .
     * @private
     */


    TaskbarEdit.prototype.updateTooltip = function (e) {
      var tooltip = document.getElementById(this.parent.element.id + '_editingtooltip_content');

      if (!sf.base.isNullOrUndefined(tooltip)) {
        var item = this.taskBarEditRecord;
        var taskWidth = item.width;
        var progressWidth = item.progressWidth;
        var taskbarPosition = this.parent.getOffsetRect(this.taskBarEditElement);
        var mousePostion = this.parent.tooltipModule.getPointerPosition(e);
        var arrowEle = sf.base.select('.' + 'e-arrow-tip', tooltip);
        var tipWidthAdjust = arrowEle.offsetWidth / 2 + (tooltip.offsetWidth - tooltip.clientWidth);
        var tipHeightAdjust = arrowEle.offsetHeight / 2 + (tooltip.offsetHeight - tooltip.clientHeight);
        arrowEle.style.left = '2px';

        if (this.taskBarEditAction === 'ConnectorPointLeftDrag' || this.taskBarEditAction === 'ConnectorPointRightDrag') {
          return;
        } else {
          if (this.taskBarEditAction === 'LeftResizing') {
            tooltip.style.left = taskbarPosition.left - tipWidthAdjust + 'px';
          } else if (this.taskBarEditAction === 'RightResizing' || this.taskBarEditAction === 'ParentResizing') {
            tooltip.style.left = taskbarPosition.left + taskWidth - tipWidthAdjust + 'px';
          } else if (this.taskBarEditAction === 'ProgressResizing') {
            tooltip.style.left = taskbarPosition.left + progressWidth - tipWidthAdjust + 'px';
          } else if (this.taskBarEditAction === 'MilestoneDrag') {
            tooltip.style.left = mousePostion.x - tipWidthAdjust + 'px';
          } else if (taskWidth > 5) {
            tooltip.style.left = mousePostion.x - tipWidthAdjust + 'px';
          }

          tooltip.style.top = taskbarPosition.top - tooltip.offsetHeight - tipHeightAdjust - 2 + 'px';
        }

        tooltip.style.visibility = 'visible';
      }
    };

    TaskbarEdit.prototype.setItemPosition = function () {
      var item = this.taskBarEditRecord;

      if (item == null || this.taskBarEditElement == null) {
        return;
      }

      var width = this.taskBarEditAction === 'MilestoneDrag' || item.isMilestone ? this.milestoneHeight : item.width;
      var rightResizer = width - 10;
      var connectorResizer = width - 2;
      var progressResizer = item.progress / 100 * item.width;
      /* tslint:disable-next-line */

      var taskBarMainContainer$$1 = !this.taskBarEditElement.classList.contains(taskBarMainContainer) ? sf.base.closest(this.taskBarEditElement, 'tr.' + chartRow).querySelector('.' + taskBarMainContainer) : this.taskBarEditElement;
      var leftLabelContainer$$1 = sf.base.closest(this.taskBarEditElement, 'tr.' + chartRow).querySelector('.' + leftLabelContainer);
      var rightLabelContainer$$1 = sf.base.closest(this.taskBarEditElement, 'tr.' + chartRow).querySelector('.' + rightLabelContainer);
      var traceChildProgressBar$$1 = this.taskBarEditElement.querySelector('.' + traceChildProgressBar);
      var traceChildTaskBar$$1 = this.taskBarEditElement.querySelector('.' + traceChildTaskBar);
      var childProgressResizer$$1 = this.taskBarEditElement.querySelector('.' + childProgressResizer);
      var taskBarRightResizer$$1 = this.taskBarEditElement.querySelector('.' + taskBarRightResizer);
      var traceParentTaskBar$$1 = this.taskBarEditElement.querySelector('.' + traceParentTaskBar);
      var traceParentProgressBar$$1 = this.taskBarEditElement.querySelector('.' + traceParentProgressBar);
      var rightConnectorPointOuterDiv$$1 = this.taskBarEditElement.querySelector('.' + rightConnectorPointOuterDiv);

      if (this.parent.biggerMode) {
        rightResizer = width - 24;
        connectorResizer = width + 10;
      }

      if (this.taskBarEditAction !== 'ParentResizing') {
        taskBarMainContainer$$1.style.width = width + 'px';
        taskBarMainContainer$$1.style.left = item.left + 'px';
        leftLabelContainer$$1.style.width = item.left + 'px';

        if (!sf.base.isNullOrUndefined(rightLabelContainer$$1)) {
          rightLabelContainer$$1.style.left = item.left + width + 'px';
        }
      }

      if (rightConnectorPointOuterDiv$$1) {
        rightConnectorPointOuterDiv$$1.style.left = connectorResizer + 'px';
      }

      if (taskBarRightResizer$$1) {
        taskBarRightResizer$$1.style.left = rightResizer + 'px';
      }

      if (this.taskBarEditAction === 'MilestoneDrag' || item.isMilestone) {
        taskBarMainContainer$$1.style.left = item.left - width / 2 + 'px';
        leftLabelContainer$$1.style.width = item.left - width / 2 + 'px';

        if (!sf.base.isNullOrUndefined(rightLabelContainer$$1)) {
          rightLabelContainer$$1.style.left = item.left + width / 2 + 'px';
        }
      } else if (this.taskBarEditAction === 'ProgressResizing') {
        traceChildTaskBar$$1.style.left = item.left + item.progressWidth - 10 + 'px';

        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          traceChildProgressBar$$1.style.width = item.progressWidth + 'px';
          traceChildProgressBar$$1.style.borderBottomRightRadius = this.progressBorderRadius + 'px';
          traceChildProgressBar$$1.style.borderTopRightRadius = this.progressBorderRadius + 'px';
          childProgressResizer$$1.style.left = item.progressWidth - 8 + 'px';
        }
      } else if (this.taskBarEditAction === 'RightResizing') {
        traceChildTaskBar$$1.style.width = width + 'px';

        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          traceChildProgressBar$$1.style.width = progressResizer + 'px';
          taskBarRightResizer$$1.style.left = rightResizer + 'px';
          childProgressResizer$$1.style.left = progressResizer - 5 + 'px';
        }
      } else if (this.taskBarEditAction === 'ParentDrag') {
        if (!sf.base.isNullOrUndefined(traceParentTaskBar$$1)) {
          traceParentTaskBar$$1.style.width = width + 'px';
        }

        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          traceParentProgressBar$$1.style.width = item.progressWidth + 'px';
        }
      } else {
        if (!sf.base.isNullOrUndefined(traceChildTaskBar$$1)) {
          traceChildTaskBar$$1.style.width = width + 'px';
        }

        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          taskBarRightResizer$$1.style.left = rightResizer + 'px';
          traceChildProgressBar$$1.style.width = progressResizer + 'px';
          childProgressResizer$$1.style.left = progressResizer - 5 + 'px';
        }
      }
    };
    /**
     * To update left and width while perform taskbar left resize operation.
     * @return {void}
     * @private
     */


    TaskbarEdit.prototype.enableLeftResizing = function (e) {
      var item = this.taskBarEditRecord;
      var diffrenceWidth = 0;

      if (this.mouseDownX > this.mouseMoveX) {
        if (this.mouseMoveX < item.left + item.width) {
          diffrenceWidth = this.mouseDownX - this.mouseMoveX;

          if (item.left > 0) {
            item.left = this.previousItem.left - diffrenceWidth;
            item.width = this.previousItem.width + diffrenceWidth;
          }
        } else {
          if (this.mouseMoveX > item.left + item.width) {
            diffrenceWidth = this.mouseDownX - this.mouseMoveX;
            item.left = this.previousItem.left - diffrenceWidth;
            item.width = 3;
          }
        }
      } else {
        if (this.mouseMoveX < item.left + item.width) {
          diffrenceWidth = this.mouseMoveX - this.mouseDownX;

          if (item.left < item.left + item.width && this.previousItem.left + diffrenceWidth <= this.previousItem.left + this.previousItem.width) {
            item.left = this.previousItem.left + diffrenceWidth;
            item.width = this.previousItem.width - diffrenceWidth;
          }
        } else {
          diffrenceWidth = this.mouseMoveX - this.mouseDownX;
          item.left = this.previousItem.left + diffrenceWidth;
          item.width = 3;
        }
      }

      this.updateEditPosition(e, item);
      item.left = this.previousItem.left + this.previousItem.width - item.width;
    };

    TaskbarEdit.prototype.enableRightResizing = function (e) {
      var item = this.taskBarEditRecord;
      var differenceWidth = 0;

      if (this.mouseDownX > this.mouseMoveX) {
        if (this.mouseMoveX > item.left && this.mouseDownX - this.mouseMoveX > 3) {
          differenceWidth = this.mouseDownX - this.mouseMoveX;
          item.width = this.previousItem.width - differenceWidth;
        } else {
          if (this.mouseMoveX < item.left) {
            item.width = 3;
          }
        }
      } else {
        if (this.mouseMoveX > item.left) {
          differenceWidth = this.mouseMoveX - this.mouseDownX;
          item.width = this.previousItem.width + differenceWidth;
        }
      }

      this.updateEditPosition(e, item);
    };

    TaskbarEdit.prototype.enableDragging = function (e) {
      var item = this.taskBarEditRecord;
      var differenceWidth = 0;

      if (this.mouseDownX > this.mouseMoveX) {
        differenceWidth = this.mouseDownX - this.mouseMoveX;

        if (differenceWidth > 0) {
          item.left = this.previousItem.left - differenceWidth;
        }
      } else {
        differenceWidth = this.mouseMoveX - this.mouseDownX;
        item.left = this.previousItem.left + differenceWidth;
      }

      var left = item.left < 0 ? 0 : item.left + item.width >= this.parent.totalTimelineWidth ? this.parent.totalTimelineWidth - item.width : item.left;
      item.left = left;
    };

    TaskbarEdit.prototype.performProgressResize = function (e) {
      var item = this.taskBarEditRecord;
      var diffrenceWidth = 0;

      if (this.mouseDownX > this.mouseMoveX) {
        if (this.mouseMoveX > item.left && this.mouseMoveX < item.left + item.width && item.left > 0) {
          diffrenceWidth = this.mouseMoveX - item.left;
          item.progressWidth = diffrenceWidth;
        } else {
          if (this.mouseMoveX >= item.left + item.width) {
            item.progressWidth = item.width;
          } else {
            item.progressWidth = 0;
          }
        }
      } else {
        if (this.mouseMoveX > item.left && this.mouseMoveX < item.left + item.width) {
          diffrenceWidth = this.mouseMoveX - item.left;
          item.progressWidth = diffrenceWidth;
        } else {
          if (this.mouseMoveX <= item.left) {
            item.progressWidth = 0;
          } else {
            item.progressWidth = item.width;
          }
        }
      }

      var widthValue = item.progressWidth > item.width ? item.width : item.progressWidth;
      widthValue = item.progressWidth < 0 ? 0 : item.progressWidth;
      item.progressWidth = widthValue;
      var diff = item.width - item.progressWidth;

      if (diff <= 4) {
        this.progressBorderRadius = 4 - diff;
      } else {
        this.progressBorderRadius = 0;
      }
    };

    TaskbarEdit.prototype.updateEditPosition = function (e, item) {
      this.updateIsMilestone(item);
    };

    TaskbarEdit.prototype.updateIsMilestone = function (item) {
      if (item.width <= 3) {
        item.width = 3;
        item.isMilestone = true;
      } else {
        item.isMilestone = false;
      }
    };

    TaskbarEdit.prototype.updateConnectorLineSecondProperties = function (e) {
      var target = this.getElementByPosition(e);
      var element = this.parent.getParentElement(target, taskBarMainContainer);
      this.connectorSecondAction = null;
      var scrollTop = 0;

      if (this.parent.getParentElement(target, connectorPointLeft)) {
        this.connectorSecondAction = 'ConnectorPointLeftDrag';
        this.toPredecessorText = 'Start';
      } else if (this.parent.getParentElement(target, connectorPointRight)) {
        this.connectorSecondAction = 'ConnectorPointRightDrag';
        this.toPredecessorText = 'Finish';
      } else {
        this.connectorSecondAction = null;
        this.toPredecessorText = null;
      }

      if (this.taskBarEditElement !== element && this.taskBarEditElement !== this.highlightedSecondElement) {
        this.elementOffsetLeft = this.taskBarEditElement.offsetLeft;
        this.elementOffsetTop = this.taskBarEditElement.offsetTop + scrollTop;
        this.elementOffsetWidth = this.taskBarEditElement.offsetWidth;
        this.elementOffsetHeight = this.taskBarEditElement.offsetHeight;
        this.showHideTaskBarEditingElements(element, this.highlightedSecondElement);
      }

      if (sf.base.isNullOrUndefined(this.connectorSecondAction) && !sf.base.isNullOrUndefined(this.connectorSecondElement)) {
        this.connectorSecondElement.querySelector('.' + connectorPointLeft).classList.remove(connectorPointAllowBlock);
        this.connectorSecondElement.querySelector('.' + connectorPointRight).classList.remove(connectorPointAllowBlock);
      }

      this.connectorSecondElement = this.connectorSecondAction ? element : null;
      this.toDataGuid = sf.base.isNullOrUndefined(this.connectorSecondElement) ? null : this.connectorSecondElement.getAttribute('rowuniqueid');
    };

    TaskbarEdit.prototype.showHideTaskBarEditingElements = function (element, secondElement) {
      secondElement = secondElement ? secondElement : this.taskBarEditElement;

      if (secondElement && element !== secondElement) {
        if (secondElement.querySelector('.' + taskBarLeftResizer)) {
          secondElement.querySelector('.' + taskBarLeftResizer).classList.remove(leftResizeGripper);
          secondElement.querySelector('.' + taskBarRightResizer).classList.remove(rightResizeGripper);

          if (secondElement.querySelector('.' + childProgressResizer)) {
            secondElement.querySelector('.' + childProgressResizer).classList.remove(progressResizeGripper);
          }
        }

        if (secondElement.querySelector('.' + connectorPointLeft) || secondElement.parentElement.querySelector('.' + connectorPointLeft)) {
          var connectorElement = !sf.base.isNullOrUndefined(secondElement.querySelector('.' + connectorPointLeft)) ? secondElement : secondElement.parentElement;
          connectorElement.querySelector('.' + connectorPointLeft).classList.remove(connectorPointLeftHover);
          connectorElement.querySelector('.' + connectorPointRight).classList.remove(connectorPointRightHover);
        }
      }
    };

    TaskbarEdit.prototype.triggerDependencyEvent = function (e, mouseUp) {
      var _this_1 = this;

      this.parent.dotNetRef.invokeMethodAsync("DrawConnectorLine", this.taskBarEditAction, this.connectorSecondAction, this.toDataGuid).then(function (drawLine) {
        if (!drawLine) {
          var target = _this_1.getElementByPosition(e);

          if (target.classList.contains(connectorPointLeft) || target.classList.contains(connectorPointRight)) target.classList.add(connectorPointAllowBlock);
        } else {
          var tooltip = document.getElementById(_this_1.parent.element.id + '_editingtooltip_content');

          if (!sf.base.isNullOrUndefined(tooltip)) {
            var mousePostion = _this_1.parent.tooltipModule.getPointerPosition(e);

            var arrowEle = sf.base.select('.' + 'e-arrow-tip', tooltip);
            var tipWidthAdjust = arrowEle.offsetWidth / 2 + (tooltip.offsetWidth - tooltip.clientWidth);
            tooltip.style.left = mousePostion.x - tipWidthAdjust + 'px';
            tooltip.style.visibility = 'visible';
          }
        }
      });
    };

    TaskbarEdit.prototype.drawFalseLine = function () {
      var x1 = this.mouseDownX;
      var y1 = this.mouseDownY;
      var x2 = this.mouseMoveX;
      var y2 = this.mouseMoveY;
      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
      var transform = 'rotate(' + angle + 'deg)';
      var left;

      if (this.taskBarEditAction === 'ConnectorPointLeftDrag') {
        left = this.elementOffsetLeft - this.connectorPointWidth / 2 - this.parent.chartPreviousScroll.left;
      }

      if (this.taskBarEditAction === 'ConnectorPointRightDrag') {
        left = this.elementOffsetLeft + this.elementOffsetWidth + this.connectorPointWidth / 2 - this.parent.chartPreviousScroll.left;
      }

      var top = this.elementOffsetTop + this.elementOffsetHeight / 2 + this.chartBodyContainer.offsetTop - this.parent.chartPreviousScroll.top;
      this.removeFalseLine(false);
      this.falseLine = document.createElement('div');
      this.falseLine.className = falseLine;
      this.falseLine.id = 'ganttfalseline' + this.parent.element.id;
      this.falseLine.style.transformOrigin = '0% 100%';
      this.falseLine.style.right = 'auto';
      this.falseLine.style.position = 'absolute';
      this.falseLine.style.transform = transform;
      this.falseLine.style.borderTopWidth = '1px';
      this.falseLine.style.borderTopStyle = 'dashed';
      this.falseLine.style.zIndex = '5';
      this.falseLine.style.width = length - 3 + 'px';
      this.falseLine.style.left = left + 'px';
      this.falseLine.style.top = top + 'px';
      this.chartBodyContainer.appendChild(this.falseLine);
    };

    TaskbarEdit.prototype.removeFalseLine = function (isRemoveConnectorPointDisplay) {
      if (this.falseLine) {
        sf.base.remove(this.falseLine);
        this.falseLine = null;

        if (isRemoveConnectorPointDisplay) {
          this.elementOffsetLeft = 0;
          this.elementOffsetTop = 0;
          this.elementOffsetWidth = 0;
          this.elementOffsetHeight = 0;

          if (!sf.base.isNullOrUndefined(this.chartBodyContainer.querySelector('.' + connectorLineContainer))) {
            sf.base.removeClass(this.chartBodyContainer.querySelectorAll('.' + connectorLineContainer), connectorLineZIndex);
          }
        }
      }
    };

    TaskbarEdit.prototype.destroy = function () {
      this.stopScrollTimer();
      this.removeEventListeners();
    };

    return TaskbarEdit;
  }();
  /**
   * Keyboard module is used to define the keyboard interactions.
   */


  var KeyboardHandler =
  /** @class */
  function () {
    function KeyboardHandler(parent) {
      this.parent = parent;
    }

    KeyboardHandler.prototype.taskbarFocus = function (tdElem) {
      var taskbarElem = tdElem.querySelector('.' + traceChildTaskBar);
      var parentTaskbarElem = tdElem.querySelector('.' + traceParentTaskBar);

      if (taskbarElem) {
        taskbarElem.focus();
        tdElem.querySelector('.' + taskBarMainContainer).querySelector('.' + traceChildTaskBar).classList.add(Active);
      } else {
        parentTaskbarElem.focus();
        tdElem.querySelector('.' + taskBarMainContainer).querySelector('.' + traceParentTaskBar).classList.add(Active);
      }

      return "isNextTaskbar";
    };

    KeyboardHandler.prototype.RightLabelFocus = function (tdElem) {
      var rightLabelElem = tdElem.querySelector('.' + rightLabelContainer);
      rightLabelElem.focus();
      rightLabelElem.querySelector('.e-label').classList.add(Active);
      return "isNextRightLabel";
    };

    KeyboardHandler.prototype.LeftLabelFocus = function (tdElem) {
      var leftLabelElem = tdElem.querySelector('.' + leftLabelContainer);
      leftLabelElem.focus();
      leftLabelElem.querySelector('.e-label').classList.add(Active);
      return "isNextLeftLabel";
    };

    return KeyboardHandler;
  }();
  /**
   * File for handling tooltip in Gantt.
   */


  var Tooltip =
  /** @class */
  function () {
    function Tooltip(parent) {
      this.parent = parent;
      this.chartPane = this.parent.element.querySelector(".e-gantt-chart-pane");
      this.addEventListeners();
    }

    Tooltip.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseMove, this);
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove, this);
    };

    Tooltip.prototype.removeEventListeners = function () {
      sf.base.EventHandler.remove(this.chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseMove);
      sf.base.EventHandler.remove(this.chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove);
    };

    Tooltip.prototype.ganttMouseMove = function (event) {
      this.tooltipMouseEvent = event;
    };

    Tooltip.prototype.tooltipOpened = function (args) {
      var tooltip = document.getElementById(args.element.id);

      if (sf.base.isNullOrUndefined(this.tooltipMouseEvent)) {
        return;
      }

      var postion = this.getPointerPosition(this.tooltipMouseEvent);
      var containerPosition = this.parent.getOffsetRect(this.chartPane);
      var bottomEnd = containerPosition.top + this.chartPane.offsetHeight;
      var rightEnd = containerPosition.left + this.chartPane.offsetWidth;
      var tooltipPositionX = postion.x;
      var tooltipPositionY = postion.y;

      if (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
        while (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
          tooltipPositionX = rightEnd - tooltip.offsetWidth - 10;
          tooltip.style.left = tooltipPositionX + 'px';
        }
      } else {
        tooltipPositionX = tooltipPositionX + 10;
        tooltip.style.left = tooltipPositionX + 'px';
      }

      if (window.innerHeight < tooltip.offsetHeight + tooltipPositionY) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      }

      if (bottomEnd < tooltipPositionY + tooltip.offsetHeight + 20) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      } else {
        tooltipPositionY = tooltipPositionY + 10;
      }

      tooltip.style.top = tooltipPositionY + "px";
      tooltip.style.visibility = 'visible';
    };

    Tooltip.prototype.predecessorTooltipOpened = function (args) {
      var tooltip = document.getElementById(args.element.id);

      if (sf.base.isNullOrUndefined(this.tooltipMouseEvent)) {
        return;
      }

      var postion = this.getPointerPosition(this.tooltipMouseEvent);
      var containerPosition = this.parent.getOffsetRect(this.chartPane);
      var bottomEnd = containerPosition.top + this.chartPane.offsetHeight;
      var rightEnd = containerPosition.left + this.chartPane.offsetWidth;
      var tooltipPositionX = postion.x;
      var tooltipPositionY = postion.y;

      if (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
        while (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
          tooltipPositionX = rightEnd - tooltip.offsetWidth - 10;
          tooltip.style.left = tooltipPositionX + 'px';
        }
      } else {
        tooltipPositionX = tooltipPositionX;
        tooltip.style.left = tooltipPositionX + 'px';
      }

      if (window.innerHeight < tooltip.offsetHeight + tooltipPositionY) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      }

      if (bottomEnd < tooltipPositionY + tooltip.offsetHeight + 20) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      } else {
        tooltipPositionY = tooltipPositionY + 10;
      }

      if (document.getElementsByClassName("e-arrow-tip e-tip-bottom").length > 0) {
        var tipPointer = document.getElementsByClassName("e-arrow-tip e-tip-bottom")[0];
        tipPointer.style.left = postion.x - tooltip.offsetLeft + "px";
      }

      tooltip.style.visibility = 'visible';
    };
    /**
     * Method to get mouse pointer position
     *
     * @param {Event} e .
     * @returns {number} .
     */


    Tooltip.prototype.getPointerPosition = function (e) {
      var posX;
      var posY;

      if (!sf.base.isNullOrUndefined(sf.base.getValue('pageX', e)) || !sf.base.isNullOrUndefined(sf.base.getValue('pageY', e))) {
        posX = sf.base.getValue('pageX', e);
        posY = sf.base.getValue('pageY', e);
      } else if (!sf.base.isNullOrUndefined(sf.base.getValue('touches[0].pageX', e)) || !sf.base.isNullOrUndefined(sf.base.getValue('touches[0].pageY', e))) {
        posX = sf.base.getValue('touches[0].pageX', e);
        posY = sf.base.getValue('touches[0].pageY', e);
      } else if (!sf.base.isNullOrUndefined(sf.base.getValue('clientX', e)) || !sf.base.isNullOrUndefined(sf.base.getValue('clientY', e))) {
        posX = sf.base.getValue('clientX', e) + document.body.scrollLeft + document.documentElement.scrollLeft;
        posY = sf.base.getValue('clientY', e) + document.body.scrollTop + document.documentElement.scrollTop;
      }

      return {
        x: posX,
        y: posY
      };
    };

    Tooltip.prototype.destroy = function () {
      this.removeEventListeners();
    };

    return Tooltip;
  }();
  /**
   * Blazor gantt interop handler
   */
  // tslint:disable


  var Gantt = {
    initialize: function initialize(dataId, element, options, dotnetRef) {
      var instance = new SfGantt(dataId, element, options, dotnetRef);
      this.dotnetRef = dotnetRef;
      var offset = {};
      this.instance = window.sfBlazor.getCompInstance(dataId);
      instance.height = offset.height = element.offsetHeight;
      instance.width = offset.width = element.offsetWidth;
      instance.toolbarElement = element.querySelector("#" + element.id + "_Gantt_Toolbar");

      if (!sf.base.isNullOrUndefined(instance.toolbarElement)) {
        instance.toolbarHeight = offset.toolbarHeight = instance.toolbarElement.offsetHeight;
      }

      if (document.body.classList.contains("e-bigger")) {
        instance.biggerMode = offset.biggerMode = true;
      }

      return offset;
    },
    updatesplitterHeight: function updatesplitterHeight(element) {
      var splitterElement = element.querySelector("#" + this.instance.element.id + "_Gantt_Splitter");
      splitterElement.style.height = 'calc(100% - ' + this.instance.toolbarHeight + 'px)';
    },
    adjustTable: function adjustTable(ganttElement) {
      if (this.instance.options.enableVirtualization) {
        var treeElement = document.getElementById("treeGrid" + this.instance.element.id + "_gridcontrol");
        var content = treeElement.querySelector(".e-gridcontent").querySelector('.e-virtualtable');
        var chartElement = document.getElementById(this.instance.element.id + "_chart").querySelector('.e-virtualtable');

        if (!sf.base.isNullOrUndefined(content) && !sf.base.isNullOrUndefined(chartElement)) {
          if (chartElement.style.transform == '') {
            chartElement.style.transform = content.style.transform;
          } else {
            chartElement.style.transform = chartElement.style.transform.split(',')[0].trim() + ',' + content.style.transform.split(',')[1].trim();
          }
        }
      }
    },
    setChartHeight: function setChartHeight(element) {
      var treegrid = document.getElementById("treeGrid" + this.instance.element.id + "_gridcontrol").querySelector(".e-gridcontent").querySelector('.e-virtualtrack');

      if (sf.base.isNullOrUndefined(treegrid)) {
        treegrid = document.getElementById("treeGrid" + this.instance.element.id + "_gridcontrol_content_table");
      }

      if (treegrid && treegrid.clientHeight) {
        var chart = document.getElementById(this.instance.element.id + "_chart");
        var chartContent = chart.getElementsByClassName("e-chart-rows-container")[0];
        var treegridClientHeight = document.getElementsByClassName("e-content")[0].clientHeight;
        var NonWorkingDayElementHeight = chart.getElementsByClassName("e-nonworking-day-container")[0];

        if (typeof NonWorkingDayElementHeight == "undefined" && NonWorkingDayElementHeight == null) {
          NonWorkingDayElementHeight = null;
        }

        if (treegridClientHeight < treegrid.clientHeight) {
          chartContent.style.height = treegrid.clientHeight + 1 + "px";

          if (NonWorkingDayElementHeight != null) {
            NonWorkingDayElementHeight.style.height = treegrid.clientHeight + 1 + "px";
          }
        } else {
          chartContent.style.height = treegridClientHeight - 1 + "px";

          if (NonWorkingDayElementHeight != null) {
            NonWorkingDayElementHeight.style.height = treegridClientHeight - 1 + "px";
          }
        }
      }

      if (!this.instance.scrollbarUpdate) {
        this.instance.chartScrollModule.showHideSpinner(false);
      }

      this.adjustTable(this.instance.element);
    },
    treegridHeaderAlign: function treegridHeaderAlign(element, isSingleTier) {
      if (isSingleTier) {
        sf.base.addClass(this.instance.treeGridElement.querySelectorAll('.e-headercell'), timelineSingleHeaderOuterDiv);
        sf.base.addClass(this.instance.treeGridElement.querySelectorAll('.e-columnheader'), timelineSingleHeaderOuterDiv);
        var gridHeaderHeight = this.instance.element.querySelector('.e-gridheader').offsetHeight;
        var gridContent = this.instance.element.querySelector('.e-gridcontent');
        gridContent.style.height = 'calc(100% - ' + gridHeaderHeight + 'px)';
      } else {
        sf.base.removeClass(this.instance.treeGridElement.querySelectorAll('.e-headercell'), timelineSingleHeaderOuterDiv);
        sf.base.removeClass(this.instance.treeGridElement.querySelectorAll('.e-columnheader'), timelineSingleHeaderOuterDiv);
      }
    },
    getTreeGrid: function getTreeGrid(element, isSingleTier) {
      this.hideTreeGridScrollBar(this.instance);

      if (!sf.base.isNullOrUndefined(this.instance.treeGridElement)) {
        this.instance.treeGrid = this.instance.treeGridElement.blazor_instance;
      }

      if (!this.instance.scrollbarUpdate) {
        this.instance.chartScrollModule.showHideSpinner(true);
      }

      this.treegridHeaderAlign(this.instance.element, isSingleTier);
      this.adjustTable(this.instance.element);
    },
    hideTreeGridScrollBar: function hideTreeGridScrollBar(element) {
      this.instance.treeGridElement = this.instance.element.querySelector('#treeGrid' + this.instance.element.id);
      var content = this.instance.treeGridElement.querySelector('.e-content');

      if (content) {
        content.style.height = '100%';
        this.instance.element.querySelector('.e-gridcontent').style.height = 'calc(100% - ' + this.instance.element.querySelector('.e-gridheader').offsetHeight + 'px)';
        this.instance.treeGridModule = new TreeGrid(this.instance, content);
      }

      var scrollWidth = this.getScrollbarWidth(this.instance.element);

      if (scrollWidth !== 0) {
        content.style.cssText += 'width: calc(100% + ' + (scrollWidth + 1) + 'px);';
      } else {
        content.classList.add("e-gantt-scroll-padding");
      }
    },
    getScrollbarWidth: function getScrollbarWidth(element) {
      var instance = element;
      var outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.overflow = 'scroll';
      outer.style.msOverflowStyle = 'scrollbar';
      var inner = document.createElement('div');
      outer.appendChild(inner);
      instance.appendChild(outer);
      var scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
      outer.parentNode.removeChild(outer);
      return scrollbarWidth;
    },
    getOffsetLeft: function getOffsetLeft(element) {
      var box = this.instance.element.getBoundingClientRect();
      var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
      var clientLeft = document.documentElement.clientLeft || document.body.clientLeft || 0;
      var left = box.left + scrollLeft - clientLeft;
      return Math.round(left);
    },
    tooltipOpened: function tooltipOpened(element, args) {
      this.instance.tooltipModule.tooltipOpened(args);
    },
    predecessorTooltipOpened: function predecessorTooltipOpened(element, args) {
      this.instance.tooltipModule.predecessorTooltipOpened(args);
    },
    ChartInitialize: function ChartInitialize(element, contentHeight, totalTimelineWidth, milestoneHeight, TaskbarEditingEvent) {
      this.instance.totalTimelineWidth = totalTimelineWidth;
      this.instance.isTaskbarEditingEventMapped = TaskbarEditingEvent;
      var ganttHeight = this.instance.element.offsetHeight;

      if (this.instance.options.allowTaskbarEditing) {
        this.instance.taskbarEditModule = new TaskbarEdit(this.instance);
        this.instance.taskbarEditModule.milestoneHeight = milestoneHeight;
      }

      this.instance.tooltipModule = new Tooltip(this.instance);
      this.instance.chartScrollModule = new ChartScroll(this.instance, this.instance.element, ganttHeight, contentHeight);
      this.instance.spinnerShown = false;
      var chartProp = {
        viewPortHeight: this.instance.chartScrollModule.viewPortHeight,
        chartWidth: this.instance.element.querySelector(".e-gantt-chart-pane").offsetWidth
      };
      return chartProp;
    },
    UpdateScroll: function UpdateScroll(element, scrollBarValue) {
      this.scrollBarElement = this.instance.element.querySelector('.e-chart-scroll-container');

      if (this.scrollBarElement.offsetWidth < scrollBarValue || this.scrollBarElement.scrollLeft > scrollBarValue) {
        this.scrollBarElement.scrollLeft = scrollBarValue;
      }
    },
    chartFocusOutHandler: function chartFocusOutHandler(id, element) {
      this.instance.keyboardModule = new KeyboardHandler(this.instance);
      var tdElement = this.instance.element.querySelector(".e-chart-row-cell[data-uid=" + id + "]");
      var focusElement = tdElement.querySelector('.' + Active) ? tdElement.querySelector('.' + Active).parentElement : null;

      if (focusElement) {
        focusElement.querySelector('.e-label').classList.remove(Active);
        focusElement.blur();
      }
    },
    focusOutHandler: function focusOutHandler(elem) {
      if (!sf.base.isNullOrUndefined(elem.classList)) {
        elem.classList.remove(Active);
      }
    },
    resetPrivateProperties: function resetPrivateProperties(element) {
      this.instance.taskbarEditModule.tappedPoint = null;
    },
    tabFocusHandler: function tabFocusHandler(id, element, isShift) {
      this.instance.keyboardModule = new KeyboardHandler(this.instance);
      var tdElem = this.instance.element.querySelector(".e-chart-row-cell[data-uid=" + id + "]");
      var focusElem = tdElem.querySelector('.' + Active) ? tdElem.querySelector('.' + Active).parentElement : null;

      if (!focusElem) {
        var result = "isNextLeftLabel";

        if (!isShift && tdElem.querySelector('.' + LeftLabel)) {
          result = this.instance.keyboardModule.LeftLabelFocus(tdElem);
        } else if (isShift && tdElem.querySelector('.' + RightLabel)) {
          result = this.instance.keyboardModule.RightLabelFocus(tdElem);
        } else {
          result = this.instance.keyboardModule.taskbarFocus(tdElem);
        }

        return result;
      } else if (focusElem.classList.contains(LeftLabel)) {
        if (isShift) {
          focusElem.querySelector('.e-label').classList.remove(Active);
          focusElem.blur();
          return "isNextGrid";
        } else {
          return this.instance.keyboardModule.taskbarFocus(tdElem);
        }
      } else if (!focusElem.classList.length) {
        if (!isShift) {
          if (tdElem.querySelector('.e-right-label-inner-div')) {
            return this.instance.keyboardModule.RightLabelFocus(tdElem);
          } else {
            return "isNextGrid";
          }
        } else {
          if (tdElem.querySelector('.e-left-label-inner-div')) {
            return this.instance.keyboardModule.LeftLabelFocus(tdElem);
          } else {
            return "isNextGrid";
          }
        }
      } else if (focusElem.classList.contains(RightLabel)) {
        if (isShift) {
          return this.instance.keyboardModule.taskbarFocus(tdElem);
        } else {
          return "isNextGrid";
        }
      } else {
        return "";
      }
    },
    getChartWidth: function getChartWidth(element) {
      return this.instance.element.querySelector('.e-gantt-chart-pane').clientWidth;
    },
    updateScrollLeft: function updateScrollLeft(element, scrollLeft, index) {
      var chartElement = this.instance.element.querySelector('.e-chart-scroll-container');

      if (index != null) {
        var taskbarHeight = this.instance.element.querySelector('.e-row').offsetHeight;
        var ScrollTop = index * taskbarHeight;

        if (chartElement.offsetHeight - taskbarHeight / 2 + chartElement.scrollTop < ScrollTop || chartElement.scrollTop > ScrollTop) {
          chartElement.scrollTop = ScrollTop;
        }
      }

      scrollLeft = scrollLeft > 0 ? scrollLeft : 0;
      scrollLeft = chartElement.scrollWidth <= scrollLeft ? chartElement.scrollWidth : scrollLeft;

      if (chartElement.offsetWidth + chartElement.scrollLeft < scrollLeft || chartElement.scrollLeft > scrollLeft) {
        chartElement.scrollLeft = scrollLeft - 50;
      }
    }
  };
  return Gantt;
}();

/***/ })

}]);(async()=>{await import("/_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js").then(()=>{sfBlazor.loadDependencies('sfgantt');})})();