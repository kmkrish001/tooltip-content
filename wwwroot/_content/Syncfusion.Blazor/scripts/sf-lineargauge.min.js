(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-lineargauge"],{

/***/ "./bundles/sf-lineargauge.js":
/*!***********************************!*\
  !*** ./bundles/sf-lineargauge.js ***!
  \***********************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-lineargauge.js */ "./modules/sf-lineargauge.js");
/* harmony import */ var _modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-lineargauge.js":
/*!***********************************!*\
  !*** ./modules/sf-lineargauge.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.LinearGauge = function () {
  'use strict';
  /* eslint-disable @typescript-eslint/member-delimiter-style */

  /* eslint-disable @typescript-eslint/naming-convention */

  /* eslint-disable @typescript-eslint/dot-notation */

  /* eslint-disable max-len */

  /**
   * LinearGauge Blazor introp module
   */

  var SfLinearGauge =
  /** @class */
  function () {
    // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
    function SfLinearGauge(id, element, options, dotnetRef) {
      this.dragMillisecond = 0; // eslint-disable-next-line @typescript-eslint/no-explicit-any

      this.valueToCoefficient = function (numberValue, options) {
        var result = (numberValue - options.Minimum) / options.Maximum;
        result = options.Orientation === 'Vertical' ? !options.IsInversed ? 1 - result : result : !options.IsInversed ? result : 1 - result;
        return result;
      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any


      this.barAnimationProgress = function (options, timeStamp, element, start, val) {
        var currentValue = options.PointerValue > options.PreviousPointerValue ? start + timeStamp * val : start + timeStamp * (options.PreviousPointerValue - val);
        var endValue = options.PointerValue > options.PreviousPointerValue ? currentValue + options.PreviousPointerValue < options.PointerValue ? currentValue + options.PreviousPointerValue : options.PointerValue : options.PreviousPointerValue - currentValue;
        var maxValue = this.valueToCoefficient(endValue, options) * options.RectHeight + options.RectY;
        var minValue = this.valueToCoefficient(options.Minimum, options) * options.RectHeight + options.RectY;
        var currentHeight = Math.abs(maxValue - minValue);

        if (options.Orientation === 'Vertical') {
          options.PointerBoundY = !options.IsInversed ? maxValue : minValue;
          options.PointerBoundHeight = currentHeight;

          if (options.PointerType === 'Bar' && options.ContainerType === "Normal") {
            element.setAttribute('y', options.PointerBoundY.toString());
            element.setAttribute('height', options.PointerBoundHeight.toString());
            element.setAttribute('x', options.PointerBoundX.toString());
            element.setAttribute('width', options.PointerWidth.toString());
          }

          if (element.tagName === "path") {
            element.setAttribute('d', this.getPathContainer(options));
          }
        } else {
          options.PointerBoundX = options.IsInversed ? maxValue : minValue;
          options.PointerBoundWidth = currentHeight;

          if (options.PointerType === 'Bar' && options.ContainerType === "Normal") {
            element.setAttribute('x', options.PointerBoundX.toString());
            element.setAttribute('width', options.PointerBoundWidth.toString());
            element.setAttribute('y', options.PointerBoundY.toString());
            element.setAttribute('height', options.PointerHeight.toString());
          }

          if (element.tagName === "path") {
            element.setAttribute('d', this.getPathContainer(options));
          }
        }
      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any


      this.markerAnimationProgress = function (options, timeStamp, element, start, val) {
        var currentValue = options.PointerValue > options.PreviousPointerValue ? start + timeStamp * val : start + timeStamp * (options.PreviousPointerValue - val);
        var endValue = options.PointerValue > options.PreviousPointerValue ? currentValue + options.PreviousPointerValue < options.PointerValue ? currentValue + options.PreviousPointerValue : options.PointerValue : options.PreviousPointerValue - currentValue;

        if (options.Orientation === 'Vertical') {
          var locationX = options.PointerBoundX;
          options.PointerBoundY = this.valueToCoefficient(endValue, options) * options.RectHeight + options.RectY;

          if (options.MarkerType === 'Circle') {
            var radius = (options.PointerWidth + options.PointerHeight) / 4;
            var cx = !options.OpposedPosition ? options.Placement != 'Far' ? locationX - radius : locationX + radius : options.Placement == 'Near' ? locationX - radius : locationX + radius;
            element.setAttribute('cy', options.PointerBoundY.toString());
            element.setAttribute('cx', cx.toString());
          } else if (options.MarkerType === 'Image' || options.MarkerType === 'Rectangle') {
            var x = !options.OpposedPosition && options.Placement != 'Far' || options.OpposedPosition && options.Placement == 'Near' ? locationX - options.PointerWidth : locationX;
            element.setAttribute('y', (options.PointerBoundY - options.PointerHeight / 2).toString());
            element.setAttribute('x', x.toString());
          } else {
            element.setAttribute('d', this.calculateShapes(options));
          }
        } else {
          options.PointerBoundX = this.valueToCoefficient(endValue, options) * options.RectHeight + options.RectY;
          var locationY = options.PointerBoundY;

          if (options.MarkerType === 'Circle') {
            var radius = (options.PointerWidth + options.PointerHeight) / 4;
            var cy = !options.OpposedPosition ? options.Placement == 'Far' ? locationY + radius : locationY - radius : options.Placement == 'Near' ? locationY - radius : locationY + radius;
            element.setAttribute('cx', options.PointerBoundX.toString());
            element.setAttribute('cy', cy.toString());
          } else if (options.MarkerType === 'Image' || options.MarkerType === 'Rectangle') {
            var height = options.PointerHeight;
            var y = !options.OpposedPosition ? options.Placement == 'Far' ? locationY + height / 2 : locationY - height / 2 : options.Placement == 'Near' ? locationY - height / 2 : locationY + height / 2;
            element.setAttribute('x', (options.PointerBoundX - options.PointerWidth / 2).toString());
            element.setAttribute('y', y.toString());
          } else {
            element.setAttribute('d', this.calculateShapes(options));
          }
        }
      };

      this.id = id;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.options = options;
      this.element.blazor__instance = this;
    }

    SfLinearGauge.prototype.render = function () {
      this.wireEvents();
    };

    SfLinearGauge.prototype.wireEvents = function () {
      /*! Bind the Event handler */
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchStartEvent, this.gaugeOnMouseDown, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchMoveEvent, this.gaugeOnMouseMove, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchEndEvent, this.gaugeOnMouseEnd, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchCancelEvent, this.gaugeOnMouseEnd, this);
      sf.base.EventHandler.add(this.element, 'click', this.gaugeOnMouseClick, this);
      sf.base.EventHandler.add(this.element, 'mouseleave', this.gaugeOnMouseLeave, this);
      window.addEventListener(sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.gaugeOnResize.bind(this));
    };

    SfLinearGauge.prototype.gaugeOnResize = function () {
      var width;
      var height;

      if (!sf.base.isNullOrUndefined(this.element)) {
        var svgElement = document.getElementById(this.element.id + '_svg');

        if (!sf.base.isNullOrUndefined(svgElement)) {
          svgElement.style.display = 'none';
          var elementRect = this.element.getBoundingClientRect();
          width = elementRect.width;
          height = elementRect.height;
          svgElement.style.removeProperty('display');
        }
      }

      if (this.previousHeight !== height || this.previousWidth !== width) {
        this.previousHeight = height;
        this.previousWidth = width;

        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerResizeEvent', width, height);
        }
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseClick = function (element) {
      var targetId = element.target.id;

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = false;
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseLeave = function (element) {
      this.dotNetRef.invokeMethodAsync('TriggerMouseLeaveEvent', element.x, element.y);
    };

    SfLinearGauge.prototype.gaugeOnMouseDown = function (element) {
      var targetId = element.target.id;
      var clientX = 0;
      var clientY = 0;

      if (element.type === 'touchstart') {
        element.preventDefault();
        clientX = element['touches'][0].clientX;
        clientY = element['touches'][0].clientY;
      } else {
        clientX = element.pageX;
        clientY = element.pageY;
      }

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = true;
        this.pointerId = targetId;
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);

        if (!sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex]) {
          this.dotNetRef.invokeMethodAsync('TriggerDragStart', axisIndex, pointerIndex);
        }
      } else {
        this.dotNetRef.invokeMethodAsync('TriggerMouseDownEvent', clientX, clientY);
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseMove = function (element) {
      var currentDate = new Date();
      var targetId = this.pointerCheck ? this.pointerId : element.target.id;
      var moveClientX = 0;
      var moveClientY = 0;

      if (element.type === 'touchmove') {
        moveClientX = element['touches'][0].clientX;
        moveClientY = element['touches'][0].clientY;
      } else {
        moveClientX = element.clientX;
        moveClientY = element.clientY;
      }

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        var svgBounds = this.svgClient(targetId);
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);

        if (this.pointerCheck && (this.dragMillisecond == 0 || Math.abs(currentDate.getMilliseconds() - this.dragMillisecond) > 80) && !sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex]) {
          this.dragMillisecond = currentDate.getMilliseconds();
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'grabbing');
          this.dotNetRef.invokeMethodAsync('TriggerDrag', targetId, axisIndex, pointerIndex, moveClientX - svgBounds.left, moveClientY - svgBounds.top);
        } else if (!this.pointerCheck && !sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex]) {
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'pointer');
        }
      } else {
        document.getElementById(this.id + '_svg').setAttribute('cursor', 'auto');
      }

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1 || targetId.indexOf('Range') > -1) {
        var svgBounds = this.svgClient(targetId);
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);
        var parentId = targetId.split('_')[0];
        var parentElement = document.getElementById(parentId).getBoundingClientRect();
        var parentEle = {
          Bottom: parentElement['bottom'],
          Height: parentElement['height'],
          Left: parentElement['left'],
          Right: parentElement['right'],
          Top: parentElement['top'],
          Width: parentElement['width'],
          X: parentElement['x'],
          Y: parentElement['y']
        };
        var lineElement = document.getElementById(parentId + '_AxisLine_' + axisIndex).getBoundingClientRect();
        var lineEle = {
          Bottom: lineElement['bottom'],
          Height: lineElement['height'],
          Left: lineElement['left'],
          Right: lineElement['right'],
          Top: lineElement['top'],
          Width: lineElement['width'],
          X: lineElement['x'],
          Y: lineElement['y']
        };
        var tickElement = document.getElementById(parentId + '_MajorTicksLine_' + axisIndex).getBoundingClientRect();
        var tickEle = {
          Bottom: tickElement['bottom'],
          Height: tickElement['height'],
          Left: tickElement['left'],
          Right: tickElement['right'],
          Top: tickElement['top'],
          Width: tickElement['width'],
          X: tickElement['x'],
          Y: tickElement['y']
        };
        var pointElement = document.getElementById(targetId).getBoundingClientRect();
        var pointEle = {
          Bottom: pointElement['bottom'],
          Height: pointElement['height'],
          Left: pointElement['left'],
          Right: pointElement['right'],
          Top: pointElement['top'],
          Width: pointElement['width'],
          X: pointElement['x'],
          Y: pointElement['y']
        };
        var elementId = targetId.split('_')[0];
        var tooltipElement = document.getElementById(elementId + '_Tooltip');

        if (tooltipElement != null) {
          tooltipElement.style.visibility = 'visible';
        }

        this.dotNetRef.invokeMethodAsync('TriggerTooltip', targetId, axisIndex, pointerIndex, moveClientX - svgBounds.left, moveClientY - svgBounds.top, parentEle, lineEle, tickEle, pointEle);
      } else {
        var elementId = targetId.split('_')[0];
        var tooltipElement = document.getElementById(elementId + '_Tooltip');

        if (tooltipElement != null) {
          tooltipElement.style.visibility = 'hidden';
        }
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseEnd = function (element) {
      var targetId = this.pointerCheck ? this.pointerId : element.target.id;
      var clientX = 0;
      var clientY = 0;

      if (element.type === 'touchend') {
        var touchArg = element;
        clientX = touchArg.changedTouches[0].pageX;
        clientY = touchArg.changedTouches[0].pageY;
      } else {
        clientX = element.clientX;
        clientY = element.clientY;
      }

      this.pointerCheck = false;

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = false;
        this.dragMillisecond = 0;
        this.pointerId = "";
        var svgBounds = this.svgClient(targetId);
        var parentId = targetId.split('_AxisIndex_')[0].split('_')[0];
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);

        if (!sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex]) {
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'pointer');
          this.dotNetRef.invokeMethodAsync('TriggerDragEnd', axisIndex, pointerIndex, parentId, targetId, clientX - svgBounds.left, clientY - svgBounds.top);
        }
      } else {
        this.dotNetRef.invokeMethodAsync('TriggerMouseUpEvent', clientX, clientY);
      }
    };

    SfLinearGauge.prototype.svgClient = function (targetId) {
      var svg = document.getElementById(targetId.split('_AxisIndex_')[0] + '_svg');
      return svg.getBoundingClientRect();
    };

    SfLinearGauge.prototype.pointerAnimation = function (options) {
      var _this = this;

      var element = document.getElementById(options.AnimationId);
      var start = options.Minimum;
      var end = options.PointerValue;
      start = start === end ? options.Minimum : start;
      var val = Math.abs(start - end);
      var timeStamp;
      new sf.base.Animation({}).animate(element, {
        duration: options.Duration,
        progress: function progress(args) {
          timeStamp = args.timeStamp / options.Duration;

          if (options.PointerType != 'Bar') {
            _this.markerAnimationProgress(options, timeStamp, element, start, val);
          } else {
            _this.barAnimationProgress(options, timeStamp, element, start, val);
          }
        },
        end: function end(args) {
          timeStamp = 1;

          if (options.PointerType != 'Bar') {
            _this.markerAnimationProgress(options, timeStamp, element, start, val);
          } else {
            _this.barAnimationProgress(options, timeStamp, element, start, val);
          }
        }
      });
    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any


    SfLinearGauge.prototype.getPathContainer = function (options) {
      var path = ' ';
      var radius = options.CornerRadius;
      var rectWidth = options.PointerBoundWidth;
      var rectHeight = options.PointerBoundHeight;
      var orientation = options.Orientation;
      var isInversed = options.IsInversed;
      var pointerType = options.PointerType;
      var pointerBoundX = options.PointerBoundX;
      var pointerBoundY = options.PointerBoundY;
      var bottomRadius = 0;
      var topRadius = 0;

      switch (options.ContainerType) {
        case 'RoundedRectangle':
          var horizontalCurve = pointerBoundX + rectWidth - radius;
          var verticalCurve = pointerBoundY + rectHeight - radius;
          var verticalRadius = radius + pointerBoundY;
          var horizontalRadius = radius + pointerBoundX;

          if (pointerType === 'Bar' && (orientation === 'Vertical' && rectHeight !== 0 || orientation === 'Horizontal' && rectWidth !== 0)) {
            if (horizontalRadius > pointerBoundX + rectWidth / 2) {
              horizontalRadius = horizontalCurve = pointerBoundX + rectWidth / 2;
            }

            if (verticalRadius > pointerBoundY + rectHeight / 2) {
              verticalRadius = verticalCurve = pointerBoundY + rectHeight / 2;
            }
          }

          if (pointerType === 'Bar' && (orientation === 'Vertical' && rectHeight === 0 || orientation === 'Horizontal' && rectWidth === 0)) {
            if (rectWidth < radius / 2 && !isInversed) {
              horizontalCurve = horizontalCurve + radius + radius / 2;
            } else if (rectWidth < radius / 2 && isInversed) {
              horizontalRadius = pointerBoundX - Math.ceil(radius / 4);
            }

            if (rectHeight < radius / 2 && !isInversed) {
              verticalRadius = pointerBoundY - Math.ceil(radius / 4);
            } else if (rectHeight < radius / 2 && isInversed) {
              verticalCurve = verticalCurve + radius + radius / 2;
            }
          }

          path = 'M' + ' ' + pointerBoundX + ' ' + verticalRadius + ' Q ' + pointerBoundX + ' ' + pointerBoundY + ' ' + horizontalRadius + ' ' + pointerBoundY + ' ' + 'L' + ' ' + horizontalCurve + ' ' + pointerBoundY + ' Q ' + (pointerBoundX + rectWidth) + ' ' + pointerBoundY + ' ' + (pointerBoundX + rectWidth) + ' ' + verticalRadius + ' ' + 'L ' + (pointerBoundX + rectWidth) + ' ' + verticalCurve + ' Q ' + (pointerBoundX + rectWidth) + ' ' + (pointerBoundY + rectHeight) + ' ' + horizontalCurve + ' ' + (pointerBoundY + rectHeight) + ' ' + ' L ' + horizontalRadius + ' ' + (pointerBoundY + rectHeight) + ' Q ' + pointerBoundX + ' ' + (pointerBoundY + rectHeight) + ' ' + pointerBoundX + ' ' + verticalCurve + ' ' + 'L' + ' ' + pointerBoundX + ' ' + verticalRadius + ' ' + 'z';
          break;

        case 'Thermometer':
          var width = orientation === 'Vertical' ? rectWidth : rectHeight;
          bottomRadius = width + width / 2 / Math.PI;
          topRadius = width / 2;

          if (orientation === 'Vertical') {
            var addValue = options.ContainerWidth + options.ContainerWidth / 2 / Math.PI - bottomRadius;
            var boundY = pointerType === 'Bar' ? pointerBoundY + addValue : pointerBoundY;
            var locationY = pointerType === 'Bar' ? pointerBoundY + (topRadius - topRadius / Math.PI) : pointerBoundY;
            var locHeight = rectHeight;
            path = 'M' + pointerBoundX + ' ' + (boundY + locHeight) + ' A ' + bottomRadius + ' ' + bottomRadius + ', 0, 1, 0, ' + (pointerBoundX + rectWidth) + ' ' + (boundY + locHeight) + ' L ' + (pointerBoundX + rectWidth) + ' ' + locationY + ' A ' + topRadius + ' ' + topRadius + ', 0, 1, 0, ' + pointerBoundX + ' ' + locationY + ' z ';
          } else {
            var pointX = pointerType === 'Bar' && !options.IsInversed ? pointerBoundX - (options.ContainerWidth + options.ContainerWidth / 2 / Math.PI - bottomRadius) : pointerBoundX;
            var locWidth = pointerType === 'Bar' ? rectWidth - (topRadius - topRadius / Math.PI) : rectWidth;
            path = 'M' + pointX + ' ' + pointerBoundY + ' A ' + bottomRadius + ' ' + bottomRadius + ', 0, 1, 0, ' + pointX + ' ' + (pointerBoundY + rectHeight) + ' L ' + ((pointerType === 'Bar' ? pointerBoundX : pointX) + locWidth) + ' ' + (pointerBoundY + rectHeight) + ' A ' + topRadius + ' ' + topRadius + ', 0, 1, 0, ' + ((pointerType === 'Bar' ? pointerBoundX : pointX) + locWidth) + ' ' + pointerBoundY + ' z ';
          }

          break;
      }

      return path;
    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any


    SfLinearGauge.prototype.calculateShapes = function (options) {
      var path;
      var width = options.PointerWidth;
      var height = options.PointerHeight;
      var locationX = options.PointerBoundX;
      var locationY = options.PointerBoundY;
      var pointerPlacement = options.Placement;
      var isOpposedPosition = options.OpposedPosition;
      var orientation = options.Orientation;

      switch (options.MarkerType) {
        case 'Diamond':
          locationX = orientation === 'Horizontal' ? locationX - width / 2 : !isOpposedPosition && pointerPlacement !== 'Far' || isOpposedPosition && pointerPlacement === 'Near' ? locationX - width : locationX;
          locationY = orientation === 'Vertical' ? locationY : !isOpposedPosition ? pointerPlacement === 'Far' ? locationY + height / 2 : locationY - height / 2 : pointerPlacement === 'Near' ? locationY - height / 2 : locationY + height / 2;
          path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + ' ' + (locationX + width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + ' ' + (locationX + width) + ' ' + locationY + ' ' + 'L' + ' ' + (locationX + width / 2) + ' ' + (locationY + height / 2) + ' ' + 'L' + ' ' + locationX + ' ' + locationY + ' z';
          break;

        case 'Triangle':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX - width) + ' ' + (locationY - height / 2) + 'L' + (locationX - width) + ' ' + (locationY + height / 2) + ' Z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY - height) + 'L' + (locationX - width / 2) + ' ' + (locationY - height) + ' Z';
          }

          break;

        case 'InvertedTriangle':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width) + ' ' + (locationY - height / 2) + 'L' + (locationX + width) + ' ' + (locationY + height / 2) + ' Z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height) + 'L' + (locationX - width / 2) + ' ' + (locationY + height) + ' Z';
          }

          break;

        case 'Arrow':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX - width) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX - width) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY + height / 2) + 'z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY - height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY - height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY - height / 2) + 'z';
          }

          break;

        case 'InvertedArrow':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + 'L' + (locationX + width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX + width) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX + width) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height / 2) + 'z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY + height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY + height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY + height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY + height / 2) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY + height / 2) + 'z';
          }

          break;
      }

      return path;
    };

    return SfLinearGauge;
  }(); // eslint-disable-next-line @typescript-eslint/no-explicit-any


  var LinearGauge = {
    initialize: function initialize(element, options, dotnetRef, style) {
      var instance = new SfLinearGauge(element.id, element, options, dotnetRef);
      instance.render();

      if (!sf.base.isNullOrUndefined(style)) {
        element.setAttribute('style', style);
      }

      return this.getElementSize(element);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementSize: function getElementSize(element) {
      var elementWidth;
      var elementHeight;

      if (element != null) {
        var elementRect = element.getBoundingClientRect();
        elementWidth = elementRect.width;
        elementHeight = elementRect.height;
      }

      return {
        width: elementWidth,
        height: elementHeight,
        isIE: sf.base.Browser.isIE
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    animationProcess: function animationProcess(element, options, pointerCount) {
      if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var pointerOptions = JSON.parse(options.animationSettings);

        for (var i = 0; i < pointerCount; i++) {
          element.blazor__instance.pointerAnimation(pointerOptions[i]);
        }
      }
    },
    setPathAttribute: function setPathAttribute(id, type, path, x, y, orientation) {
      var pathElement = document.getElementById(id);

      if (type === '') {
        pathElement.setAttribute('d', path);
      } else if (type == 'Circle') {
        if (orientation == "Horizontal") {
          pathElement.setAttribute('cx', x.toString());
        } else {
          pathElement.setAttribute('cy', y.toString());
        }
      } else if (type == 'Rectangle' || type == 'Image') {
        if (orientation == "Horizontal") {
          pathElement.setAttribute('x', x.toString());
        } else {
          pathElement.setAttribute('y', y.toString());
        }
      } else {
        pathElement.setAttribute('x', x.toString());
        pathElement.setAttribute('y', y.toString());
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateCollection: function updateCollection(element, collection) {
      if (element && element.blazor__instance) {
        element.blazor__instance.enableDragCollection = JSON.parse(collection.enableDragCollection);
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementBounds: function getElementBounds(id) {
      var htmlElement = document.getElementById(id);

      if (htmlElement) {
        var bounds = htmlElement.getBoundingClientRect();
        return {
          width: bounds.width,
          height: bounds.height,
          top: bounds.top,
          bottom: bounds.bottom,
          left: bounds.left,
          right: bounds.right
        };
      }

      return null;
    }
  };
  return LinearGauge;
}();

/***/ })

}]);(async()=>{await import("/_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js").then(()=>{sfBlazor.loadDependencies('sflineargauge');})})();