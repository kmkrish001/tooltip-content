(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-toast"],{

/***/ "./bundles/sf-toast.js":
/*!*****************************!*\
  !*** ./bundles/sf-toast.js ***!
  \*****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_toast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-toast.js */ "./modules/sf-toast.js");
/* harmony import */ var _modules_sf_toast_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_toast_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-toast.js":
/*!*****************************!*\
  !*** ./modules/sf-toast.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Toast = function () {
  'use strict';

  var CREATED_EVENT = 'CreatedEvent';
  var CLOSE_EVENT = 'CloseEvent';
  var OPEN_EVENT = 'OpenEvent';
  var ON_CLOSE_EVENT = 'OnCloseEvent';
  var DESTROY_TIMER = 'DestroyTimer';
  var MOUSEOVER_EVENT = 'MouseoverEvent';
  var CLOSEBTN = 'e-toast-close-icon';
  var ROOT = 'e-toast';
  var TOAST_BLAZOR_HIDDEN = 'e-blazor-toast-hidden';
  var PROGRESS = 'e-toast-progress';
  var HUN_PERCENT = '100%';
  var DEFAULT_WIDTH = '300px';
  var FULL_WIDTH = 'e-toast-full-width';
  var STRING = 'string';
  var RELATIVE = 'relative';
  var BODY = 'BODY';
  var RIGHT = 'Right';
  var LEFT = 'Left';
  var ELEMENT = 'element';
  var ALL = 'All';
  var ENTER_KEY = 13;
  var SPACE_KEY = 32;
  var TOAST_PRE = 'e-toast';
  var TOAST_CONTAINER = 'e-toast-container';
  var KEYDOWN = 'keydown';
  var FIXED = 'fixed';
  var ABSOLUTE = 'absolute';
  var MOUSE_OVER = 'mouseover';
  var MOUSE_LEAVE = 'mouseleave';
  var TOAST_ID = 'toast_';
  var MIN_SCREEN_WIDTH = 768;
  var TOAST_REF_ELEMENT = 'e-toast-ref-element';

  var SfToast =
  /** @class */
  function () {
    function SfToast(options) {
      this.progressObj = [];
      window.sfBlazor = window.sfBlazor;
      this.progressObj = [];
      this.updateContext(options);

      if (window.sfBlazor) {
        if (sf.base.isNullOrUndefined(window.sfBlazor.instances)) {
          window.sfBlazor.instances = [];
        }

        window.sfBlazor.instances[this.dataId] = this;
      }
    }

    SfToast.prototype.initialize = function (element) {
      this.refElement = sf.base.createElement('div', {
        className: TOAST_REF_ELEMENT
      });
      this.toastContainer = element;
      var parentEle = element.parentElement;
      parentEle.insertBefore(this.refElement, element);
      this.isDevice = sf.base.Browser.isDevice;

      if (this.width === DEFAULT_WIDTH) {
        this.width = this.isDevice && screen.width < MIN_SCREEN_WIDTH ? HUN_PERCENT : DEFAULT_WIDTH;
        this.toastContainer.classList.add(FULL_WIDTH);
      }

      if (this.isDevice && screen.width < MIN_SCREEN_WIDTH) {
        new sf.base.Touch(this.element, {
          swipe: this.swipeHandler.bind(this)
        });
      }

      this.dotNetRef.invokeMethodAsync(CREATED_EVENT, null);
    };

    SfToast.prototype.show = function (options) {
      this.setAnimation(options);
      var target = _typeof(this.target) === STRING ? document.querySelector(this.target) : document.body;
      options.rootElement.style.zIndex = sf.popups.getZindexPartial(options.rootElement) + '';

      if (sf.base.isNullOrUndefined(target)) {
        return;
      }

      if (target.tagName === BODY) {
        this.toastContainer.style.position = FIXED;
      } else {
        this.toastContainer.style.position = ABSOLUTE;
        target.style.position = RELATIVE;
      }

      target.appendChild(this.toastContainer);
      this.appendToast(options.element);
      var id = parseInt(options.element.id.split(TOAST_ID)[1], 10);
      this.progressObj[id] = {
        hideEstimatedTimeOfArrival: null,
        intervalId: null,
        maxHideTime: null,
        element: null,
        timeOutId: null,
        progressEle: null
      };
      this.progressObj[id].element = options.element;

      if (this.extendedTimeout > 0 && this.timeOut > 0) {
        sf.base.EventHandler.add(options.element, MOUSE_OVER, this.toastHoverAction.bind(this, id));
        sf.base.EventHandler.add(options.element, MOUSE_LEAVE, this.delayedToastProgress.bind(this, id));
      }

      if (options.showProgressBar) {
        this.progressObj[id].progressEle = options.element.querySelector('.' + PROGRESS);
      }

      sf.base.EventHandler.add(options.element, KEYDOWN, this.keyDownHandler, this);
    };

    SfToast.prototype.getDomObject = function (value, element) {
      if (element != null) {
        // eslint-disable-next-line
        return window.sfBlazor.getDomObject(value, element);
      } else {
        return null;
      }
    };

    SfToast.prototype.swipeHandler = function (e) {
      var toastEle = sf.base.closest(e.originalEvent.target, '.' + TOAST_PRE + ':not(.' + TOAST_CONTAINER + ')');
      var animation = this.hideAnimation.effect;

      if (!sf.base.isNullOrUndefined(toastEle)) {
        if (e.swipeDirection === RIGHT) {
          this.hideAnimation.effect = 'SlideRightOut';
          this.hide('swipe', toastEle);
        } else if (e.swipeDirection === LEFT) {
          this.hideAnimation.effect = 'SlideLeftOut';
          this.hide('swipe', toastEle);
        }

        this.hideAnimation.effect = animation;
      }
    };

    SfToast.prototype.delayedToastProgress = function (id) {
      var progress = this.progressObj[id];
      var toastEle = progress.element;
      progress.timeOutId = window.setTimeout(this.destroyToast.bind(this, toastEle), this.extendedTimeout);
      progress.maxHideTime = parseFloat(this.extendedTimeout + '');
      progress.hideEstimatedTimeOfArrival = new Date().getTime() + progress.maxHideTime;

      if (!sf.base.isNullOrUndefined(toastEle.querySelector('.' + PROGRESS))) {
        progress.intervalId = setInterval(this.updateProgressBar.bind(this, progress), 10);
      }
    };

    SfToast.prototype.toastHoverAction = function (id) {
      this.dotNetRef.invokeMethodAsync('ClearTimeout', id);
      clearTimeout(this.progressObj[id].timeOutId);
      clearInterval(this.progressObj[id].intervalId);
      this.progressObj[id].hideEstimatedTimeOfArrival = 0;
      var toastEle = this.progressObj[id].element;

      if (!sf.base.isNullOrUndefined(toastEle.querySelector('.' + PROGRESS))) {
        this.progressObj[id].progressEle.style.width = '0%';
      }

      this.dotNetRef.invokeMethodAsync(MOUSEOVER_EVENT, id);
    };

    SfToast.prototype.updateProgressBar = function (progressObj) {
      var percentage = (progressObj.hideEstimatedTimeOfArrival - new Date().getTime()) / progressObj.maxHideTime * 100;
      percentage = this.progressDirection === 'LTR' ? 100 - percentage : percentage;
      progressObj.progressEle.style.width = percentage + '%';
    };

    SfToast.prototype.appendToast = function (toastElement) {
      if (this.newestOnTop && this.toastContainer.childElementCount !== 0) {
        this.toastContainer.insertBefore(toastElement, this.toastContainer.children[0]);
      }

      sf.base.removeClass([toastElement], TOAST_BLAZOR_HIDDEN);
    };

    SfToast.prototype.setAnimation = function (toastObj) {
      var _this = this;

      var proxy = this;
      var showAnimate = this.showAnimation;
      var animate = {
        duration: showAnimate.duration,
        name: showAnimate.effect,
        timingFunction: showAnimate.easing
      };

      animate.begin = function () {
        toastObj.element.style.display = '';
      };

      animate.end = function () {
        if (!sf.base.isNullOrUndefined(document.querySelector('#' + proxy.element.id))) {
          proxy.dotNetRef.invokeMethodAsync(OPEN_EVENT, toastObj.index, _this.getDomObject(ELEMENT, toastObj.element));
        }
      };

      new sf.base.Animation(animate).animate(toastObj.element);
    };

    SfToast.prototype.hide = function (interactionType, element) {
      if (sf.base.isNullOrUndefined(this.toastContainer) || this.toastContainer.childElementCount === 0) {
        return;
      }

      if (_typeof(element) === STRING && element === ALL) {
        for (var i = 0; i < this.toastContainer.childElementCount; i++) {
          this.destroyToast(this.toastContainer.children[i], interactionType);
        }

        return;
      } else if (_typeof(element) === STRING && element !== ALL) {
        var ele = this.toastContainer.querySelector('#toast_' + element);

        if (ele) {
          this.destroyToast(ele, interactionType);
          this.dotNetRef.invokeMethodAsync(DESTROY_TIMER, parseInt(element, 10));
        }
      }

      if (sf.base.isNullOrUndefined(element)) {
        element = this.newestOnTop ? this.toastContainer.lastElementChild : this.toastContainer.firstElementChild;
      }

      this.destroyToast(element, interactionType);
      var id = parseInt(element.id.split('toast_')[1], 10);
      this.dotNetRef.invokeMethodAsync(DESTROY_TIMER, id);
    };

    SfToast.prototype.destroyToast = function (element, interactionType) {
      if (this.toastContainer.attributes.length === 0) {
        return;
      }

      var id = parseInt(element.id.split('toast_')[1], 10);
      this.dotNetRef.invokeMethodAsync(ON_CLOSE_EVENT, id, interactionType);
    };

    SfToast.prototype.hideAnimationToast = function (element, index) {
      var proxy = this;
      var hideAnimate = this.hideAnimation;
      var animate = {
        duration: hideAnimate.duration,
        name: hideAnimate.effect,
        timingFunction: hideAnimate.easing
      };

      animate.end = function () {
        sf.base.detach(element);
        proxy.dotNetRef.invokeMethodAsync(CLOSE_EVENT, index);
      };

      new sf.base.Animation({}).animate(element, animate);
    };

    SfToast.prototype.destroy = function () {
      while (this.toastContainer.attributes.length > 0) {
        this.toastContainer.removeAttribute(this.toastContainer.attributes[0].name);
      }

      var splitNodes = this.toastContainer.children;

      for (var i = splitNodes.length - 1; i >= 0; i--) {
        sf.base.detach(splitNodes[i]);
      }

      if (!sf.base.isNullOrUndefined(this.refElement) && !sf.base.isNullOrUndefined(this.refElement.parentElement)) {
        this.refElement.parentElement.insertBefore(this.toastContainer, this.refElement);
        sf.base.detach(this.refElement);
        this.refElement = undefined;
      }
    };

    SfToast.prototype.keyDownHandler = function (e) {
      if (e.target.classList.contains(CLOSEBTN) && (e.keyCode === ENTER_KEY || e.keyCode === SPACE_KEY)) {
        var target = e.target;
        var toastEle = sf.base.closest(target, '.' + ROOT);
        this.destroyToast(toastEle, 'key');
      }
    };

    SfToast.prototype.updateContext = function (toastObj) {
      sf.base.extend(this, this, toastObj);
    };

    return SfToast;
  }(); // eslint-disable-next-line


  var Toast = {
    initialize: function initialize(options) {
      if (options.dataId) {
        new SfToast(options);
        window.sfBlazor.instances[options.dataId].initialize(options.element);
      }
    },
    show: function show(toastObj) {
      if (toastObj.rootElement) {
        window.sfBlazor.instances[toastObj.dataId].updateContext(toastObj);
        window.sfBlazor.instances[toastObj.dataId].show(toastObj);
      }
    },
    hideAnimationToast: function hideAnimationToast(dataId, index) {
      if (dataId) {
        window.sfBlazor.instances[dataId].hideAnimationToast(document.querySelector('#toast_' + index), index);
      }
    },
    hide: function hide(toastElement, toastObj, interactionType) {
      if (toastObj.dataId) {
        window.sfBlazor.instances[toastObj.dataId].updateContext(toastObj);
        window.sfBlazor.instances[toastObj.dataId].hide(interactionType, toastElement);
      }
    },
    appendToast: function appendToast(dataId, toastElement, toastObj) {
      if (dataId) {
        window.sfBlazor.instances[toastObj.dataId].appendToast(toastElement);
      }
    },
    destroy: function destroy(dataId) {
      if (dataId) {
        window.sfBlazor.instances[dataId].destroy();
      }
    }
  };
  return Toast;
}();

/***/ })

}]);(async()=>{await import("/_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js").then(()=>{sfBlazor.loadDependencies('sftoast');})})();